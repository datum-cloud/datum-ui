/* eslint-disable */
import type { GraphQLResolveInfo, GraphQLScalarType, GraphQLScalarTypeConfig } from 'graphql';
import type { GraphQLClient } from 'graphql-request';
import type { GraphQLClientRequestHeaders } from 'graphql-request/build/cjs/types';
import gql from 'graphql-tag';
import type { ClientError } from 'graphql-request/dist/types';
import type { SWRConfiguration as SWRConfigInterface, Key as SWRKeyInterface } from 'swr';
import useSWR from 'swr';
import { gql } from '@apollo/client';
import * as Apollo from '@apollo/client';
export type Maybe<T> = T | null;
export type InputMaybe<T> = T | null;
export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };
export type MakeEmpty<T extends { [key: string]: unknown }, K extends keyof T> = { [_ in K]?: never };
export type Incremental<T> = T | { [P in keyof T]?: P extends ' $fragmentName' | '__typename' ? T[P] : never };
export type RequireFields<T, K extends keyof T> = Omit<T, K> & { [P in K]-?: NonNullable<T[P]> };
const defaultOptions = {} as const;
/** All built-in and custom scalars, mapped to their actual values */
export interface Scalars {
  ID: { input: string; output: string; }
  String: { input: string; output: string; }
  Boolean: { input: boolean; output: boolean; }
  Int: { input: number; output: number; }
  Float: { input: number; output: number; }
  /**
   * Define a Relay Cursor type:
   * https://relay.dev/graphql/connections.htm#sec-Cursor
   */
  Cursor: { input: any; output: any; }
  /** A valid JSON string. */
  JSON: { input: any; output: any; }
  /** The builtin Time type */
  Time: { input: any; output: any; }
}

/**
 * CreateEntitlementInput is used for create Entitlement object.
 * Input was generated by ent.
 */
export interface CreateEntitlementInput {
  /** whether or not the customer has cancelled their entitlement - usually used in conjunction with expires and expires at */
  cancelled: InputMaybe<Scalars['Boolean']['input']>;
  createdAt: InputMaybe<Scalars['Time']['input']>;
  createdBy: InputMaybe<Scalars['String']['input']>;
  /** whether or not the customers entitlement expires - expires_at will show the time */
  expires: InputMaybe<Scalars['Boolean']['input']>;
  /** the time at which a customer's entitlement will expire, e.g. they've cancelled but paid through the end of the month */
  expiresAt: InputMaybe<Scalars['Time']['input']>;
  /** used to store references to external systems, e.g. Stripe */
  externalCustomerID: InputMaybe<Scalars['String']['input']>;
  /** used to store references to external systems, e.g. Stripe */
  externalSubscriptionID: InputMaybe<Scalars['String']['input']>;
  ownerID: Scalars['ID']['input'];
  tier: InputMaybe<EntitlementTier>;
  updatedAt: InputMaybe<Scalars['Time']['input']>;
  updatedBy: InputMaybe<Scalars['String']['input']>;
}

/**
 * CreateGroupInput is used for create Group object.
 * Input was generated by ent.
 */
export interface CreateGroupInput {
  createdAt: InputMaybe<Scalars['Time']['input']>;
  createdBy: InputMaybe<Scalars['String']['input']>;
  /** the groups description */
  description: InputMaybe<Scalars['String']['input']>;
  /** The group's displayed 'friendly' name */
  displayName: InputMaybe<Scalars['String']['input']>;
  /** the URL to an auto generated gravatar image for the group */
  gravatarLogoURL: InputMaybe<Scalars['String']['input']>;
  /** the URL to an image uploaded by the customer for the groups avatar image */
  logoURL: InputMaybe<Scalars['String']['input']>;
  /** the name of the group - must be unique within the organization */
  name: Scalars['String']['input'];
  ownerID: Scalars['ID']['input'];
  settingID: Scalars['ID']['input'];
  updatedAt: InputMaybe<Scalars['Time']['input']>;
  updatedBy: InputMaybe<Scalars['String']['input']>;
  userIDs: InputMaybe<Array<Scalars['ID']['input']>>;
}

/**
 * CreateGroupMembershipInput is used for create GroupMembership object.
 * Input was generated by ent.
 */
export interface CreateGroupMembershipInput {
  createdAt: InputMaybe<Scalars['Time']['input']>;
  createdBy: InputMaybe<Scalars['String']['input']>;
  groupID: Scalars['ID']['input'];
  role: InputMaybe<GroupMembershipRole>;
  updatedAt: InputMaybe<Scalars['Time']['input']>;
  updatedBy: InputMaybe<Scalars['String']['input']>;
  userID: Scalars['ID']['input'];
}

/**
 * CreateGroupSettingInput is used for create GroupSetting object.
 * Input was generated by ent.
 */
export interface CreateGroupSettingInput {
  createdAt: InputMaybe<Scalars['Time']['input']>;
  createdBy: InputMaybe<Scalars['String']['input']>;
  groupID: InputMaybe<Scalars['ID']['input']>;
  /** the policy governing ability to freely join a group, whether it requires an invitation, application, or either */
  joinPolicy: InputMaybe<GroupSettingJoinPolicy>;
  syncToGithub: InputMaybe<Scalars['Boolean']['input']>;
  syncToSlack: InputMaybe<Scalars['Boolean']['input']>;
  /** tags associated with the object */
  tags: InputMaybe<Array<Scalars['String']['input']>>;
  updatedAt: InputMaybe<Scalars['Time']['input']>;
  updatedBy: InputMaybe<Scalars['String']['input']>;
  /** whether the group is visible to it's members / owners only or if it's searchable by anyone within the organization */
  visibility: InputMaybe<GroupSettingVisibility>;
}

/**
 * CreateIntegrationInput is used for create Integration object.
 * Input was generated by ent.
 */
export interface CreateIntegrationInput {
  createdAt: InputMaybe<Scalars['Time']['input']>;
  createdBy: InputMaybe<Scalars['String']['input']>;
  /** a description of the integration */
  description: InputMaybe<Scalars['String']['input']>;
  kind: InputMaybe<Scalars['String']['input']>;
  /** the name of the integration - must be unique within the organization */
  name: Scalars['String']['input'];
  ownerID: InputMaybe<Scalars['ID']['input']>;
  secretName: Scalars['String']['input'];
  updatedAt: InputMaybe<Scalars['Time']['input']>;
  updatedBy: InputMaybe<Scalars['String']['input']>;
}

/**
 * CreateOauthProviderInput is used for create OauthProvider object.
 * Input was generated by ent.
 */
export interface CreateOauthProviderInput {
  /** the auth style, 0: auto detect 1: third party log in 2: log in with username and password */
  authStyle: Scalars['Int']['input'];
  /** the auth url of the provider */
  authURL: Scalars['String']['input'];
  /** the client id for the oauth provider */
  clientID: Scalars['String']['input'];
  /** the client secret */
  clientSecret: Scalars['String']['input'];
  createdAt: InputMaybe<Scalars['Time']['input']>;
  createdBy: InputMaybe<Scalars['String']['input']>;
  /** the URL to request user information by token */
  infoURL: Scalars['String']['input'];
  /** the oauth provider's name */
  name: Scalars['String']['input'];
  ownerID: InputMaybe<Scalars['ID']['input']>;
  /** the redirect url */
  redirectURL: Scalars['String']['input'];
  /** the scopes */
  scopes: Scalars['String']['input'];
  /** the token url of the provider */
  tokenURL: Scalars['String']['input'];
  updatedAt: InputMaybe<Scalars['Time']['input']>;
  updatedBy: InputMaybe<Scalars['String']['input']>;
}

/**
 * CreateOhAuthTooTokenInput is used for create OhAuthTooToken object.
 * Input was generated by ent.
 */
export interface CreateOhAuthTooTokenInput {
  claimsEmail: Scalars['String']['input'];
  claimsEmailVerified: Scalars['Boolean']['input'];
  claimsGroups: InputMaybe<Array<Scalars['String']['input']>>;
  claimsPreferredUsername: Scalars['String']['input'];
  claimsUserID: Scalars['String']['input'];
  claimsUsername: Scalars['String']['input'];
  clientID: Scalars['String']['input'];
  connectorData: InputMaybe<Array<Scalars['String']['input']>>;
  connectorID: Scalars['String']['input'];
  lastUsed: InputMaybe<Scalars['Time']['input']>;
  nonce: Scalars['String']['input'];
  scopes: InputMaybe<Array<Scalars['String']['input']>>;
}

/**
 * CreateOrgMembershipInput is used for create OrgMembership object.
 * Input was generated by ent.
 */
export interface CreateOrgMembershipInput {
  createdAt: InputMaybe<Scalars['Time']['input']>;
  createdBy: InputMaybe<Scalars['String']['input']>;
  orgID: Scalars['ID']['input'];
  role: InputMaybe<OrgMembershipRole>;
  updatedAt: InputMaybe<Scalars['Time']['input']>;
  updatedBy: InputMaybe<Scalars['String']['input']>;
  userID: Scalars['ID']['input'];
}

/**
 * CreateOrganizationInput is used for create Organization object.
 * Input was generated by ent.
 */
export interface CreateOrganizationInput {
  createOrgMembers: InputMaybe<Array<CreateOrgMembershipInput>>;
  createOrgSettings: InputMaybe<CreateOrganizationSettingInput>;
  createdAt: InputMaybe<Scalars['Time']['input']>;
  createdBy: InputMaybe<Scalars['String']['input']>;
  /** An optional description of the organization */
  description: InputMaybe<Scalars['String']['input']>;
  /** The organization's displayed 'friendly' name */
  displayName: InputMaybe<Scalars['String']['input']>;
  entitlementIDs: InputMaybe<Array<Scalars['ID']['input']>>;
  groupIDs: InputMaybe<Array<Scalars['ID']['input']>>;
  integrationIDs: InputMaybe<Array<Scalars['ID']['input']>>;
  /** the name of the organization */
  name: Scalars['String']['input'];
  oauthproviderIDs: InputMaybe<Array<Scalars['ID']['input']>>;
  parentID: InputMaybe<Scalars['ID']['input']>;
  /** orgs directly associated with a user */
  personalOrg: InputMaybe<Scalars['Boolean']['input']>;
  settingID: InputMaybe<Scalars['ID']['input']>;
  updatedAt: InputMaybe<Scalars['Time']['input']>;
  updatedBy: InputMaybe<Scalars['String']['input']>;
  userIDs: InputMaybe<Array<Scalars['ID']['input']>>;
}

/**
 * CreateOrganizationSettingInput is used for create OrganizationSetting object.
 * Input was generated by ent.
 */
export interface CreateOrganizationSettingInput {
  billingAddress: InputMaybe<Scalars['String']['input']>;
  /** Name of the person to contact for billing */
  billingContact: InputMaybe<Scalars['String']['input']>;
  billingEmail: InputMaybe<Scalars['String']['input']>;
  billingPhone: InputMaybe<Scalars['String']['input']>;
  createdAt: InputMaybe<Scalars['Time']['input']>;
  createdBy: InputMaybe<Scalars['String']['input']>;
  /** domains associated with the organization */
  domains: InputMaybe<Array<Scalars['String']['input']>>;
  organizationID: InputMaybe<Scalars['ID']['input']>;
  ssoCert: InputMaybe<Scalars['String']['input']>;
  ssoEntrypoint: InputMaybe<Scalars['String']['input']>;
  ssoIssuer: InputMaybe<Scalars['String']['input']>;
  /** tags associated with the object */
  tags: InputMaybe<Array<Scalars['String']['input']>>;
  /** Usually government-issued tax ID or business ID such as ABN in Australia */
  taxIdentifier: InputMaybe<Scalars['String']['input']>;
  updatedAt: InputMaybe<Scalars['Time']['input']>;
  updatedBy: InputMaybe<Scalars['String']['input']>;
}

/**
 * CreatePersonalAccessTokenInput is used for create PersonalAccessToken object.
 * Input was generated by ent.
 */
export interface CreatePersonalAccessTokenInput {
  /** what abilites the token should have */
  abilities: InputMaybe<Array<Scalars['String']['input']>>;
  createdAt: InputMaybe<Scalars['Time']['input']>;
  createdBy: InputMaybe<Scalars['String']['input']>;
  /** a description of the token's purpose */
  description: InputMaybe<Scalars['String']['input']>;
  /** when the token expires */
  expiresAt: Scalars['Time']['input'];
  lastUsedAt: InputMaybe<Scalars['Time']['input']>;
  /** the name associated with the token */
  name: Scalars['String']['input'];
  ownerID: Scalars['ID']['input'];
  token: InputMaybe<Scalars['String']['input']>;
  updatedAt: InputMaybe<Scalars['Time']['input']>;
  updatedBy: InputMaybe<Scalars['String']['input']>;
}

/**
 * CreateSessionInput is used for create Session object.
 * Input was generated by ent.
 */
export interface CreateSessionInput {
  createdAt: InputMaybe<Scalars['Time']['input']>;
  createdBy: InputMaybe<Scalars['String']['input']>;
  expiresAt: Scalars['Time']['input'];
  issuedAt: Scalars['Time']['input'];
  /** organization ID of the organization the user is accessing */
  organizationID: Scalars['String']['input'];
  ownerID: Scalars['ID']['input'];
  /** token is a string token issued to users that has a limited lifetime */
  sessionToken: Scalars['String']['input'];
  updatedAt: InputMaybe<Scalars['Time']['input']>;
  updatedBy: InputMaybe<Scalars['String']['input']>;
}

/**
 * CreateUserInput is used for create User object.
 * Input was generated by ent.
 */
export interface CreateUserInput {
  /** The user's local avatar file */
  avatarLocalFile: InputMaybe<Scalars['String']['input']>;
  /** URL of the user's remote avatar */
  avatarRemoteURL: InputMaybe<Scalars['String']['input']>;
  /** The time the user's (local) avatar was last updated */
  avatarUpdatedAt: InputMaybe<Scalars['Time']['input']>;
  createdAt: InputMaybe<Scalars['Time']['input']>;
  createdBy: InputMaybe<Scalars['String']['input']>;
  /** The user's displayed 'friendly' name */
  displayName: InputMaybe<Scalars['String']['input']>;
  email: Scalars['String']['input'];
  emailVerificationTokenIDs: InputMaybe<Array<Scalars['ID']['input']>>;
  firstName: Scalars['String']['input'];
  groupIDs: InputMaybe<Array<Scalars['ID']['input']>>;
  lastName: Scalars['String']['input'];
  /** the time the user was last seen */
  lastSeen: InputMaybe<Scalars['Time']['input']>;
  /** whether the user uses oauth for login or not */
  oauth: InputMaybe<Scalars['Boolean']['input']>;
  organizationIDs: InputMaybe<Array<Scalars['ID']['input']>>;
  /** user password hash */
  password: InputMaybe<Scalars['String']['input']>;
  passwordResetTokenIDs: InputMaybe<Array<Scalars['ID']['input']>>;
  personalAccessTokenIDs: InputMaybe<Array<Scalars['ID']['input']>>;
  sessionIDs: InputMaybe<Array<Scalars['ID']['input']>>;
  settingID: Scalars['ID']['input'];
  /** the Subject of the user JWT */
  sub: InputMaybe<Scalars['String']['input']>;
  updatedAt: InputMaybe<Scalars['Time']['input']>;
  updatedBy: InputMaybe<Scalars['String']['input']>;
}

/**
 * CreateUserSettingInput is used for create UserSetting object.
 * Input was generated by ent.
 */
export interface CreateUserSettingInput {
  createdAt: InputMaybe<Scalars['Time']['input']>;
  createdBy: InputMaybe<Scalars['String']['input']>;
  emailConfirmed: InputMaybe<Scalars['Boolean']['input']>;
  /** user account is locked if unconfirmed or explicitly locked */
  locked: InputMaybe<Scalars['Boolean']['input']>;
  permissions: InputMaybe<Array<Scalars['String']['input']>>;
  /** local user password recovery code generated during account creation - does not exist for oauth'd users */
  recoveryCode: InputMaybe<Scalars['String']['input']>;
  role: InputMaybe<UserSettingRole>;
  /** The time notifications regarding the user were silenced */
  silencedAt: InputMaybe<Scalars['Time']['input']>;
  status: InputMaybe<UserSettingStatus>;
  /** The time the user was suspended */
  suspendedAt: InputMaybe<Scalars['Time']['input']>;
  /** tags associated with the object */
  tags: InputMaybe<Array<Scalars['String']['input']>>;
  updatedAt: InputMaybe<Scalars['Time']['input']>;
  updatedBy: InputMaybe<Scalars['String']['input']>;
  userID: InputMaybe<Scalars['ID']['input']>;
}

/** EntitlementTier is enum for the field tier */
export enum EntitlementTier {
  enterprise = 'enterprise',
  free = 'free',
  pro = 'pro'
}

/**
 * EntitlementWhereInput is used for filtering Entitlement objects.
 * Input was generated by ent.
 */
export interface EntitlementWhereInput {
  and: InputMaybe<Array<EntitlementWhereInput>>;
  /** cancelled field predicates */
  cancelled: InputMaybe<Scalars['Boolean']['input']>;
  cancelledNEQ: InputMaybe<Scalars['Boolean']['input']>;
  /** created_at field predicates */
  createdAt: InputMaybe<Scalars['Time']['input']>;
  createdAtGT: InputMaybe<Scalars['Time']['input']>;
  createdAtGTE: InputMaybe<Scalars['Time']['input']>;
  createdAtIn: InputMaybe<Array<Scalars['Time']['input']>>;
  createdAtLT: InputMaybe<Scalars['Time']['input']>;
  createdAtLTE: InputMaybe<Scalars['Time']['input']>;
  createdAtNEQ: InputMaybe<Scalars['Time']['input']>;
  createdAtNotIn: InputMaybe<Array<Scalars['Time']['input']>>;
  /** created_by field predicates */
  createdBy: InputMaybe<Scalars['String']['input']>;
  createdByContains: InputMaybe<Scalars['String']['input']>;
  createdByContainsFold: InputMaybe<Scalars['String']['input']>;
  createdByEqualFold: InputMaybe<Scalars['String']['input']>;
  createdByGT: InputMaybe<Scalars['String']['input']>;
  createdByGTE: InputMaybe<Scalars['String']['input']>;
  createdByHasPrefix: InputMaybe<Scalars['String']['input']>;
  createdByHasSuffix: InputMaybe<Scalars['String']['input']>;
  createdByIn: InputMaybe<Array<Scalars['String']['input']>>;
  createdByIsNil: InputMaybe<Scalars['Boolean']['input']>;
  createdByLT: InputMaybe<Scalars['String']['input']>;
  createdByLTE: InputMaybe<Scalars['String']['input']>;
  createdByNEQ: InputMaybe<Scalars['String']['input']>;
  createdByNotIn: InputMaybe<Array<Scalars['String']['input']>>;
  createdByNotNil: InputMaybe<Scalars['Boolean']['input']>;
  /** deleted_at field predicates */
  deletedAt: InputMaybe<Scalars['Time']['input']>;
  deletedAtGT: InputMaybe<Scalars['Time']['input']>;
  deletedAtGTE: InputMaybe<Scalars['Time']['input']>;
  deletedAtIn: InputMaybe<Array<Scalars['Time']['input']>>;
  deletedAtIsNil: InputMaybe<Scalars['Boolean']['input']>;
  deletedAtLT: InputMaybe<Scalars['Time']['input']>;
  deletedAtLTE: InputMaybe<Scalars['Time']['input']>;
  deletedAtNEQ: InputMaybe<Scalars['Time']['input']>;
  deletedAtNotIn: InputMaybe<Array<Scalars['Time']['input']>>;
  deletedAtNotNil: InputMaybe<Scalars['Boolean']['input']>;
  /** deleted_by field predicates */
  deletedBy: InputMaybe<Scalars['String']['input']>;
  deletedByContains: InputMaybe<Scalars['String']['input']>;
  deletedByContainsFold: InputMaybe<Scalars['String']['input']>;
  deletedByEqualFold: InputMaybe<Scalars['String']['input']>;
  deletedByGT: InputMaybe<Scalars['String']['input']>;
  deletedByGTE: InputMaybe<Scalars['String']['input']>;
  deletedByHasPrefix: InputMaybe<Scalars['String']['input']>;
  deletedByHasSuffix: InputMaybe<Scalars['String']['input']>;
  deletedByIn: InputMaybe<Array<Scalars['String']['input']>>;
  deletedByIsNil: InputMaybe<Scalars['Boolean']['input']>;
  deletedByLT: InputMaybe<Scalars['String']['input']>;
  deletedByLTE: InputMaybe<Scalars['String']['input']>;
  deletedByNEQ: InputMaybe<Scalars['String']['input']>;
  deletedByNotIn: InputMaybe<Array<Scalars['String']['input']>>;
  deletedByNotNil: InputMaybe<Scalars['Boolean']['input']>;
  /** expires field predicates */
  expires: InputMaybe<Scalars['Boolean']['input']>;
  /** expires_at field predicates */
  expiresAt: InputMaybe<Scalars['Time']['input']>;
  expiresAtGT: InputMaybe<Scalars['Time']['input']>;
  expiresAtGTE: InputMaybe<Scalars['Time']['input']>;
  expiresAtIn: InputMaybe<Array<Scalars['Time']['input']>>;
  expiresAtIsNil: InputMaybe<Scalars['Boolean']['input']>;
  expiresAtLT: InputMaybe<Scalars['Time']['input']>;
  expiresAtLTE: InputMaybe<Scalars['Time']['input']>;
  expiresAtNEQ: InputMaybe<Scalars['Time']['input']>;
  expiresAtNotIn: InputMaybe<Array<Scalars['Time']['input']>>;
  expiresAtNotNil: InputMaybe<Scalars['Boolean']['input']>;
  expiresNEQ: InputMaybe<Scalars['Boolean']['input']>;
  /** external_customer_id field predicates */
  externalCustomerID: InputMaybe<Scalars['String']['input']>;
  externalCustomerIDContains: InputMaybe<Scalars['String']['input']>;
  externalCustomerIDContainsFold: InputMaybe<Scalars['String']['input']>;
  externalCustomerIDEqualFold: InputMaybe<Scalars['String']['input']>;
  externalCustomerIDGT: InputMaybe<Scalars['String']['input']>;
  externalCustomerIDGTE: InputMaybe<Scalars['String']['input']>;
  externalCustomerIDHasPrefix: InputMaybe<Scalars['String']['input']>;
  externalCustomerIDHasSuffix: InputMaybe<Scalars['String']['input']>;
  externalCustomerIDIn: InputMaybe<Array<Scalars['String']['input']>>;
  externalCustomerIDIsNil: InputMaybe<Scalars['Boolean']['input']>;
  externalCustomerIDLT: InputMaybe<Scalars['String']['input']>;
  externalCustomerIDLTE: InputMaybe<Scalars['String']['input']>;
  externalCustomerIDNEQ: InputMaybe<Scalars['String']['input']>;
  externalCustomerIDNotIn: InputMaybe<Array<Scalars['String']['input']>>;
  externalCustomerIDNotNil: InputMaybe<Scalars['Boolean']['input']>;
  /** external_subscription_id field predicates */
  externalSubscriptionID: InputMaybe<Scalars['String']['input']>;
  externalSubscriptionIDContains: InputMaybe<Scalars['String']['input']>;
  externalSubscriptionIDContainsFold: InputMaybe<Scalars['String']['input']>;
  externalSubscriptionIDEqualFold: InputMaybe<Scalars['String']['input']>;
  externalSubscriptionIDGT: InputMaybe<Scalars['String']['input']>;
  externalSubscriptionIDGTE: InputMaybe<Scalars['String']['input']>;
  externalSubscriptionIDHasPrefix: InputMaybe<Scalars['String']['input']>;
  externalSubscriptionIDHasSuffix: InputMaybe<Scalars['String']['input']>;
  externalSubscriptionIDIn: InputMaybe<Array<Scalars['String']['input']>>;
  externalSubscriptionIDIsNil: InputMaybe<Scalars['Boolean']['input']>;
  externalSubscriptionIDLT: InputMaybe<Scalars['String']['input']>;
  externalSubscriptionIDLTE: InputMaybe<Scalars['String']['input']>;
  externalSubscriptionIDNEQ: InputMaybe<Scalars['String']['input']>;
  externalSubscriptionIDNotIn: InputMaybe<Array<Scalars['String']['input']>>;
  externalSubscriptionIDNotNil: InputMaybe<Scalars['Boolean']['input']>;
  /** owner edge predicates */
  hasOwner: InputMaybe<Scalars['Boolean']['input']>;
  hasOwnerWith: InputMaybe<Array<OrganizationWhereInput>>;
  /** id field predicates */
  id: InputMaybe<Scalars['ID']['input']>;
  idContainsFold: InputMaybe<Scalars['ID']['input']>;
  idEqualFold: InputMaybe<Scalars['ID']['input']>;
  idGT: InputMaybe<Scalars['ID']['input']>;
  idGTE: InputMaybe<Scalars['ID']['input']>;
  idIn: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT: InputMaybe<Scalars['ID']['input']>;
  idLTE: InputMaybe<Scalars['ID']['input']>;
  idNEQ: InputMaybe<Scalars['ID']['input']>;
  idNotIn: InputMaybe<Array<Scalars['ID']['input']>>;
  not: InputMaybe<EntitlementWhereInput>;
  or: InputMaybe<Array<EntitlementWhereInput>>;
  /** tier field predicates */
  tier: InputMaybe<EntitlementTier>;
  tierIn: InputMaybe<Array<EntitlementTier>>;
  tierNEQ: InputMaybe<EntitlementTier>;
  tierNotIn: InputMaybe<Array<EntitlementTier>>;
  /** updated_at field predicates */
  updatedAt: InputMaybe<Scalars['Time']['input']>;
  updatedAtGT: InputMaybe<Scalars['Time']['input']>;
  updatedAtGTE: InputMaybe<Scalars['Time']['input']>;
  updatedAtIn: InputMaybe<Array<Scalars['Time']['input']>>;
  updatedAtLT: InputMaybe<Scalars['Time']['input']>;
  updatedAtLTE: InputMaybe<Scalars['Time']['input']>;
  updatedAtNEQ: InputMaybe<Scalars['Time']['input']>;
  updatedAtNotIn: InputMaybe<Array<Scalars['Time']['input']>>;
  /** updated_by field predicates */
  updatedBy: InputMaybe<Scalars['String']['input']>;
  updatedByContains: InputMaybe<Scalars['String']['input']>;
  updatedByContainsFold: InputMaybe<Scalars['String']['input']>;
  updatedByEqualFold: InputMaybe<Scalars['String']['input']>;
  updatedByGT: InputMaybe<Scalars['String']['input']>;
  updatedByGTE: InputMaybe<Scalars['String']['input']>;
  updatedByHasPrefix: InputMaybe<Scalars['String']['input']>;
  updatedByHasSuffix: InputMaybe<Scalars['String']['input']>;
  updatedByIn: InputMaybe<Array<Scalars['String']['input']>>;
  updatedByIsNil: InputMaybe<Scalars['Boolean']['input']>;
  updatedByLT: InputMaybe<Scalars['String']['input']>;
  updatedByLTE: InputMaybe<Scalars['String']['input']>;
  updatedByNEQ: InputMaybe<Scalars['String']['input']>;
  updatedByNotIn: InputMaybe<Array<Scalars['String']['input']>>;
  updatedByNotNil: InputMaybe<Scalars['Boolean']['input']>;
}

/** GroupMembershipRole is enum for the field role */
export enum GroupMembershipRole {
  ADMIN = 'ADMIN',
  MEMBER = 'MEMBER',
  OWNER = 'OWNER'
}

/**
 * GroupMembershipWhereInput is used for filtering GroupMembership objects.
 * Input was generated by ent.
 */
export interface GroupMembershipWhereInput {
  and: InputMaybe<Array<GroupMembershipWhereInput>>;
  /** created_at field predicates */
  createdAt: InputMaybe<Scalars['Time']['input']>;
  createdAtGT: InputMaybe<Scalars['Time']['input']>;
  createdAtGTE: InputMaybe<Scalars['Time']['input']>;
  createdAtIn: InputMaybe<Array<Scalars['Time']['input']>>;
  createdAtLT: InputMaybe<Scalars['Time']['input']>;
  createdAtLTE: InputMaybe<Scalars['Time']['input']>;
  createdAtNEQ: InputMaybe<Scalars['Time']['input']>;
  createdAtNotIn: InputMaybe<Array<Scalars['Time']['input']>>;
  /** created_by field predicates */
  createdBy: InputMaybe<Scalars['String']['input']>;
  createdByContains: InputMaybe<Scalars['String']['input']>;
  createdByContainsFold: InputMaybe<Scalars['String']['input']>;
  createdByEqualFold: InputMaybe<Scalars['String']['input']>;
  createdByGT: InputMaybe<Scalars['String']['input']>;
  createdByGTE: InputMaybe<Scalars['String']['input']>;
  createdByHasPrefix: InputMaybe<Scalars['String']['input']>;
  createdByHasSuffix: InputMaybe<Scalars['String']['input']>;
  createdByIn: InputMaybe<Array<Scalars['String']['input']>>;
  createdByIsNil: InputMaybe<Scalars['Boolean']['input']>;
  createdByLT: InputMaybe<Scalars['String']['input']>;
  createdByLTE: InputMaybe<Scalars['String']['input']>;
  createdByNEQ: InputMaybe<Scalars['String']['input']>;
  createdByNotIn: InputMaybe<Array<Scalars['String']['input']>>;
  createdByNotNil: InputMaybe<Scalars['Boolean']['input']>;
  /** deleted_at field predicates */
  deletedAt: InputMaybe<Scalars['Time']['input']>;
  deletedAtGT: InputMaybe<Scalars['Time']['input']>;
  deletedAtGTE: InputMaybe<Scalars['Time']['input']>;
  deletedAtIn: InputMaybe<Array<Scalars['Time']['input']>>;
  deletedAtIsNil: InputMaybe<Scalars['Boolean']['input']>;
  deletedAtLT: InputMaybe<Scalars['Time']['input']>;
  deletedAtLTE: InputMaybe<Scalars['Time']['input']>;
  deletedAtNEQ: InputMaybe<Scalars['Time']['input']>;
  deletedAtNotIn: InputMaybe<Array<Scalars['Time']['input']>>;
  deletedAtNotNil: InputMaybe<Scalars['Boolean']['input']>;
  /** deleted_by field predicates */
  deletedBy: InputMaybe<Scalars['String']['input']>;
  deletedByContains: InputMaybe<Scalars['String']['input']>;
  deletedByContainsFold: InputMaybe<Scalars['String']['input']>;
  deletedByEqualFold: InputMaybe<Scalars['String']['input']>;
  deletedByGT: InputMaybe<Scalars['String']['input']>;
  deletedByGTE: InputMaybe<Scalars['String']['input']>;
  deletedByHasPrefix: InputMaybe<Scalars['String']['input']>;
  deletedByHasSuffix: InputMaybe<Scalars['String']['input']>;
  deletedByIn: InputMaybe<Array<Scalars['String']['input']>>;
  deletedByIsNil: InputMaybe<Scalars['Boolean']['input']>;
  deletedByLT: InputMaybe<Scalars['String']['input']>;
  deletedByLTE: InputMaybe<Scalars['String']['input']>;
  deletedByNEQ: InputMaybe<Scalars['String']['input']>;
  deletedByNotIn: InputMaybe<Array<Scalars['String']['input']>>;
  deletedByNotNil: InputMaybe<Scalars['Boolean']['input']>;
  /** id field predicates */
  id: InputMaybe<Scalars['ID']['input']>;
  idContainsFold: InputMaybe<Scalars['ID']['input']>;
  idEqualFold: InputMaybe<Scalars['ID']['input']>;
  idGT: InputMaybe<Scalars['ID']['input']>;
  idGTE: InputMaybe<Scalars['ID']['input']>;
  idIn: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT: InputMaybe<Scalars['ID']['input']>;
  idLTE: InputMaybe<Scalars['ID']['input']>;
  idNEQ: InputMaybe<Scalars['ID']['input']>;
  idNotIn: InputMaybe<Array<Scalars['ID']['input']>>;
  not: InputMaybe<GroupMembershipWhereInput>;
  or: InputMaybe<Array<GroupMembershipWhereInput>>;
  /** role field predicates */
  role: InputMaybe<GroupMembershipRole>;
  roleIn: InputMaybe<Array<GroupMembershipRole>>;
  roleNEQ: InputMaybe<GroupMembershipRole>;
  roleNotIn: InputMaybe<Array<GroupMembershipRole>>;
  /** updated_at field predicates */
  updatedAt: InputMaybe<Scalars['Time']['input']>;
  updatedAtGT: InputMaybe<Scalars['Time']['input']>;
  updatedAtGTE: InputMaybe<Scalars['Time']['input']>;
  updatedAtIn: InputMaybe<Array<Scalars['Time']['input']>>;
  updatedAtLT: InputMaybe<Scalars['Time']['input']>;
  updatedAtLTE: InputMaybe<Scalars['Time']['input']>;
  updatedAtNEQ: InputMaybe<Scalars['Time']['input']>;
  updatedAtNotIn: InputMaybe<Array<Scalars['Time']['input']>>;
  /** updated_by field predicates */
  updatedBy: InputMaybe<Scalars['String']['input']>;
  updatedByContains: InputMaybe<Scalars['String']['input']>;
  updatedByContainsFold: InputMaybe<Scalars['String']['input']>;
  updatedByEqualFold: InputMaybe<Scalars['String']['input']>;
  updatedByGT: InputMaybe<Scalars['String']['input']>;
  updatedByGTE: InputMaybe<Scalars['String']['input']>;
  updatedByHasPrefix: InputMaybe<Scalars['String']['input']>;
  updatedByHasSuffix: InputMaybe<Scalars['String']['input']>;
  updatedByIn: InputMaybe<Array<Scalars['String']['input']>>;
  updatedByIsNil: InputMaybe<Scalars['Boolean']['input']>;
  updatedByLT: InputMaybe<Scalars['String']['input']>;
  updatedByLTE: InputMaybe<Scalars['String']['input']>;
  updatedByNEQ: InputMaybe<Scalars['String']['input']>;
  updatedByNotIn: InputMaybe<Array<Scalars['String']['input']>>;
  updatedByNotNil: InputMaybe<Scalars['Boolean']['input']>;
}

/** Ordering options for Group connections */
export interface GroupOrder {
  /** The ordering direction. */
  direction: OrderDirection;
  /** The field by which to order Groups. */
  field: GroupOrderField;
}

/** Properties by which Group connections can be ordered. */
export enum GroupOrderField {
  display_name = 'display_name',
  name = 'name'
}

/** GroupSettingJoinPolicy is enum for the field join_policy */
export enum GroupSettingJoinPolicy {
  APPLICATION_ONLY = 'APPLICATION_ONLY',
  INVITE_ONLY = 'INVITE_ONLY',
  INVITE_OR_APPLICATION = 'INVITE_OR_APPLICATION',
  OPEN = 'OPEN'
}

/** GroupSettingVisibility is enum for the field visibility */
export enum GroupSettingVisibility {
  PRIVATE = 'PRIVATE',
  PUBLIC = 'PUBLIC'
}

/**
 * GroupSettingWhereInput is used for filtering GroupSetting objects.
 * Input was generated by ent.
 */
export interface GroupSettingWhereInput {
  and: InputMaybe<Array<GroupSettingWhereInput>>;
  /** created_at field predicates */
  createdAt: InputMaybe<Scalars['Time']['input']>;
  createdAtGT: InputMaybe<Scalars['Time']['input']>;
  createdAtGTE: InputMaybe<Scalars['Time']['input']>;
  createdAtIn: InputMaybe<Array<Scalars['Time']['input']>>;
  createdAtLT: InputMaybe<Scalars['Time']['input']>;
  createdAtLTE: InputMaybe<Scalars['Time']['input']>;
  createdAtNEQ: InputMaybe<Scalars['Time']['input']>;
  createdAtNotIn: InputMaybe<Array<Scalars['Time']['input']>>;
  /** created_by field predicates */
  createdBy: InputMaybe<Scalars['String']['input']>;
  createdByContains: InputMaybe<Scalars['String']['input']>;
  createdByContainsFold: InputMaybe<Scalars['String']['input']>;
  createdByEqualFold: InputMaybe<Scalars['String']['input']>;
  createdByGT: InputMaybe<Scalars['String']['input']>;
  createdByGTE: InputMaybe<Scalars['String']['input']>;
  createdByHasPrefix: InputMaybe<Scalars['String']['input']>;
  createdByHasSuffix: InputMaybe<Scalars['String']['input']>;
  createdByIn: InputMaybe<Array<Scalars['String']['input']>>;
  createdByIsNil: InputMaybe<Scalars['Boolean']['input']>;
  createdByLT: InputMaybe<Scalars['String']['input']>;
  createdByLTE: InputMaybe<Scalars['String']['input']>;
  createdByNEQ: InputMaybe<Scalars['String']['input']>;
  createdByNotIn: InputMaybe<Array<Scalars['String']['input']>>;
  createdByNotNil: InputMaybe<Scalars['Boolean']['input']>;
  /** deleted_at field predicates */
  deletedAt: InputMaybe<Scalars['Time']['input']>;
  deletedAtGT: InputMaybe<Scalars['Time']['input']>;
  deletedAtGTE: InputMaybe<Scalars['Time']['input']>;
  deletedAtIn: InputMaybe<Array<Scalars['Time']['input']>>;
  deletedAtIsNil: InputMaybe<Scalars['Boolean']['input']>;
  deletedAtLT: InputMaybe<Scalars['Time']['input']>;
  deletedAtLTE: InputMaybe<Scalars['Time']['input']>;
  deletedAtNEQ: InputMaybe<Scalars['Time']['input']>;
  deletedAtNotIn: InputMaybe<Array<Scalars['Time']['input']>>;
  deletedAtNotNil: InputMaybe<Scalars['Boolean']['input']>;
  /** deleted_by field predicates */
  deletedBy: InputMaybe<Scalars['String']['input']>;
  deletedByContains: InputMaybe<Scalars['String']['input']>;
  deletedByContainsFold: InputMaybe<Scalars['String']['input']>;
  deletedByEqualFold: InputMaybe<Scalars['String']['input']>;
  deletedByGT: InputMaybe<Scalars['String']['input']>;
  deletedByGTE: InputMaybe<Scalars['String']['input']>;
  deletedByHasPrefix: InputMaybe<Scalars['String']['input']>;
  deletedByHasSuffix: InputMaybe<Scalars['String']['input']>;
  deletedByIn: InputMaybe<Array<Scalars['String']['input']>>;
  deletedByIsNil: InputMaybe<Scalars['Boolean']['input']>;
  deletedByLT: InputMaybe<Scalars['String']['input']>;
  deletedByLTE: InputMaybe<Scalars['String']['input']>;
  deletedByNEQ: InputMaybe<Scalars['String']['input']>;
  deletedByNotIn: InputMaybe<Array<Scalars['String']['input']>>;
  deletedByNotNil: InputMaybe<Scalars['Boolean']['input']>;
  /** group edge predicates */
  hasGroup: InputMaybe<Scalars['Boolean']['input']>;
  hasGroupWith: InputMaybe<Array<GroupWhereInput>>;
  /** id field predicates */
  id: InputMaybe<Scalars['ID']['input']>;
  idContainsFold: InputMaybe<Scalars['ID']['input']>;
  idEqualFold: InputMaybe<Scalars['ID']['input']>;
  idGT: InputMaybe<Scalars['ID']['input']>;
  idGTE: InputMaybe<Scalars['ID']['input']>;
  idIn: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT: InputMaybe<Scalars['ID']['input']>;
  idLTE: InputMaybe<Scalars['ID']['input']>;
  idNEQ: InputMaybe<Scalars['ID']['input']>;
  idNotIn: InputMaybe<Array<Scalars['ID']['input']>>;
  /** join_policy field predicates */
  joinPolicy: InputMaybe<GroupSettingJoinPolicy>;
  joinPolicyIn: InputMaybe<Array<GroupSettingJoinPolicy>>;
  joinPolicyNEQ: InputMaybe<GroupSettingJoinPolicy>;
  joinPolicyNotIn: InputMaybe<Array<GroupSettingJoinPolicy>>;
  not: InputMaybe<GroupSettingWhereInput>;
  or: InputMaybe<Array<GroupSettingWhereInput>>;
  /** sync_to_github field predicates */
  syncToGithub: InputMaybe<Scalars['Boolean']['input']>;
  syncToGithubNEQ: InputMaybe<Scalars['Boolean']['input']>;
  /** sync_to_slack field predicates */
  syncToSlack: InputMaybe<Scalars['Boolean']['input']>;
  syncToSlackNEQ: InputMaybe<Scalars['Boolean']['input']>;
  /** updated_at field predicates */
  updatedAt: InputMaybe<Scalars['Time']['input']>;
  updatedAtGT: InputMaybe<Scalars['Time']['input']>;
  updatedAtGTE: InputMaybe<Scalars['Time']['input']>;
  updatedAtIn: InputMaybe<Array<Scalars['Time']['input']>>;
  updatedAtLT: InputMaybe<Scalars['Time']['input']>;
  updatedAtLTE: InputMaybe<Scalars['Time']['input']>;
  updatedAtNEQ: InputMaybe<Scalars['Time']['input']>;
  updatedAtNotIn: InputMaybe<Array<Scalars['Time']['input']>>;
  /** updated_by field predicates */
  updatedBy: InputMaybe<Scalars['String']['input']>;
  updatedByContains: InputMaybe<Scalars['String']['input']>;
  updatedByContainsFold: InputMaybe<Scalars['String']['input']>;
  updatedByEqualFold: InputMaybe<Scalars['String']['input']>;
  updatedByGT: InputMaybe<Scalars['String']['input']>;
  updatedByGTE: InputMaybe<Scalars['String']['input']>;
  updatedByHasPrefix: InputMaybe<Scalars['String']['input']>;
  updatedByHasSuffix: InputMaybe<Scalars['String']['input']>;
  updatedByIn: InputMaybe<Array<Scalars['String']['input']>>;
  updatedByIsNil: InputMaybe<Scalars['Boolean']['input']>;
  updatedByLT: InputMaybe<Scalars['String']['input']>;
  updatedByLTE: InputMaybe<Scalars['String']['input']>;
  updatedByNEQ: InputMaybe<Scalars['String']['input']>;
  updatedByNotIn: InputMaybe<Array<Scalars['String']['input']>>;
  updatedByNotNil: InputMaybe<Scalars['Boolean']['input']>;
  /** visibility field predicates */
  visibility: InputMaybe<GroupSettingVisibility>;
  visibilityIn: InputMaybe<Array<GroupSettingVisibility>>;
  visibilityNEQ: InputMaybe<GroupSettingVisibility>;
  visibilityNotIn: InputMaybe<Array<GroupSettingVisibility>>;
}

/**
 * GroupWhereInput is used for filtering Group objects.
 * Input was generated by ent.
 */
export interface GroupWhereInput {
  and: InputMaybe<Array<GroupWhereInput>>;
  /** created_at field predicates */
  createdAt: InputMaybe<Scalars['Time']['input']>;
  createdAtGT: InputMaybe<Scalars['Time']['input']>;
  createdAtGTE: InputMaybe<Scalars['Time']['input']>;
  createdAtIn: InputMaybe<Array<Scalars['Time']['input']>>;
  createdAtLT: InputMaybe<Scalars['Time']['input']>;
  createdAtLTE: InputMaybe<Scalars['Time']['input']>;
  createdAtNEQ: InputMaybe<Scalars['Time']['input']>;
  createdAtNotIn: InputMaybe<Array<Scalars['Time']['input']>>;
  /** created_by field predicates */
  createdBy: InputMaybe<Scalars['String']['input']>;
  createdByContains: InputMaybe<Scalars['String']['input']>;
  createdByContainsFold: InputMaybe<Scalars['String']['input']>;
  createdByEqualFold: InputMaybe<Scalars['String']['input']>;
  createdByGT: InputMaybe<Scalars['String']['input']>;
  createdByGTE: InputMaybe<Scalars['String']['input']>;
  createdByHasPrefix: InputMaybe<Scalars['String']['input']>;
  createdByHasSuffix: InputMaybe<Scalars['String']['input']>;
  createdByIn: InputMaybe<Array<Scalars['String']['input']>>;
  createdByIsNil: InputMaybe<Scalars['Boolean']['input']>;
  createdByLT: InputMaybe<Scalars['String']['input']>;
  createdByLTE: InputMaybe<Scalars['String']['input']>;
  createdByNEQ: InputMaybe<Scalars['String']['input']>;
  createdByNotIn: InputMaybe<Array<Scalars['String']['input']>>;
  createdByNotNil: InputMaybe<Scalars['Boolean']['input']>;
  /** deleted_at field predicates */
  deletedAt: InputMaybe<Scalars['Time']['input']>;
  deletedAtGT: InputMaybe<Scalars['Time']['input']>;
  deletedAtGTE: InputMaybe<Scalars['Time']['input']>;
  deletedAtIn: InputMaybe<Array<Scalars['Time']['input']>>;
  deletedAtIsNil: InputMaybe<Scalars['Boolean']['input']>;
  deletedAtLT: InputMaybe<Scalars['Time']['input']>;
  deletedAtLTE: InputMaybe<Scalars['Time']['input']>;
  deletedAtNEQ: InputMaybe<Scalars['Time']['input']>;
  deletedAtNotIn: InputMaybe<Array<Scalars['Time']['input']>>;
  deletedAtNotNil: InputMaybe<Scalars['Boolean']['input']>;
  /** deleted_by field predicates */
  deletedBy: InputMaybe<Scalars['String']['input']>;
  deletedByContains: InputMaybe<Scalars['String']['input']>;
  deletedByContainsFold: InputMaybe<Scalars['String']['input']>;
  deletedByEqualFold: InputMaybe<Scalars['String']['input']>;
  deletedByGT: InputMaybe<Scalars['String']['input']>;
  deletedByGTE: InputMaybe<Scalars['String']['input']>;
  deletedByHasPrefix: InputMaybe<Scalars['String']['input']>;
  deletedByHasSuffix: InputMaybe<Scalars['String']['input']>;
  deletedByIn: InputMaybe<Array<Scalars['String']['input']>>;
  deletedByIsNil: InputMaybe<Scalars['Boolean']['input']>;
  deletedByLT: InputMaybe<Scalars['String']['input']>;
  deletedByLTE: InputMaybe<Scalars['String']['input']>;
  deletedByNEQ: InputMaybe<Scalars['String']['input']>;
  deletedByNotIn: InputMaybe<Array<Scalars['String']['input']>>;
  deletedByNotNil: InputMaybe<Scalars['Boolean']['input']>;
  /** display_name field predicates */
  displayName: InputMaybe<Scalars['String']['input']>;
  displayNameContains: InputMaybe<Scalars['String']['input']>;
  displayNameContainsFold: InputMaybe<Scalars['String']['input']>;
  displayNameEqualFold: InputMaybe<Scalars['String']['input']>;
  displayNameGT: InputMaybe<Scalars['String']['input']>;
  displayNameGTE: InputMaybe<Scalars['String']['input']>;
  displayNameHasPrefix: InputMaybe<Scalars['String']['input']>;
  displayNameHasSuffix: InputMaybe<Scalars['String']['input']>;
  displayNameIn: InputMaybe<Array<Scalars['String']['input']>>;
  displayNameLT: InputMaybe<Scalars['String']['input']>;
  displayNameLTE: InputMaybe<Scalars['String']['input']>;
  displayNameNEQ: InputMaybe<Scalars['String']['input']>;
  displayNameNotIn: InputMaybe<Array<Scalars['String']['input']>>;
  /** members edge predicates */
  hasMembers: InputMaybe<Scalars['Boolean']['input']>;
  hasMembersWith: InputMaybe<Array<GroupMembershipWhereInput>>;
  /** owner edge predicates */
  hasOwner: InputMaybe<Scalars['Boolean']['input']>;
  hasOwnerWith: InputMaybe<Array<OrganizationWhereInput>>;
  /** setting edge predicates */
  hasSetting: InputMaybe<Scalars['Boolean']['input']>;
  hasSettingWith: InputMaybe<Array<GroupSettingWhereInput>>;
  /** users edge predicates */
  hasUsers: InputMaybe<Scalars['Boolean']['input']>;
  hasUsersWith: InputMaybe<Array<UserWhereInput>>;
  /** id field predicates */
  id: InputMaybe<Scalars['ID']['input']>;
  idContainsFold: InputMaybe<Scalars['ID']['input']>;
  idEqualFold: InputMaybe<Scalars['ID']['input']>;
  idGT: InputMaybe<Scalars['ID']['input']>;
  idGTE: InputMaybe<Scalars['ID']['input']>;
  idIn: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT: InputMaybe<Scalars['ID']['input']>;
  idLTE: InputMaybe<Scalars['ID']['input']>;
  idNEQ: InputMaybe<Scalars['ID']['input']>;
  idNotIn: InputMaybe<Array<Scalars['ID']['input']>>;
  /** name field predicates */
  name: InputMaybe<Scalars['String']['input']>;
  nameContains: InputMaybe<Scalars['String']['input']>;
  nameContainsFold: InputMaybe<Scalars['String']['input']>;
  nameEqualFold: InputMaybe<Scalars['String']['input']>;
  nameGT: InputMaybe<Scalars['String']['input']>;
  nameGTE: InputMaybe<Scalars['String']['input']>;
  nameHasPrefix: InputMaybe<Scalars['String']['input']>;
  nameHasSuffix: InputMaybe<Scalars['String']['input']>;
  nameIn: InputMaybe<Array<Scalars['String']['input']>>;
  nameLT: InputMaybe<Scalars['String']['input']>;
  nameLTE: InputMaybe<Scalars['String']['input']>;
  nameNEQ: InputMaybe<Scalars['String']['input']>;
  nameNotIn: InputMaybe<Array<Scalars['String']['input']>>;
  not: InputMaybe<GroupWhereInput>;
  or: InputMaybe<Array<GroupWhereInput>>;
  /** updated_at field predicates */
  updatedAt: InputMaybe<Scalars['Time']['input']>;
  updatedAtGT: InputMaybe<Scalars['Time']['input']>;
  updatedAtGTE: InputMaybe<Scalars['Time']['input']>;
  updatedAtIn: InputMaybe<Array<Scalars['Time']['input']>>;
  updatedAtLT: InputMaybe<Scalars['Time']['input']>;
  updatedAtLTE: InputMaybe<Scalars['Time']['input']>;
  updatedAtNEQ: InputMaybe<Scalars['Time']['input']>;
  updatedAtNotIn: InputMaybe<Array<Scalars['Time']['input']>>;
  /** updated_by field predicates */
  updatedBy: InputMaybe<Scalars['String']['input']>;
  updatedByContains: InputMaybe<Scalars['String']['input']>;
  updatedByContainsFold: InputMaybe<Scalars['String']['input']>;
  updatedByEqualFold: InputMaybe<Scalars['String']['input']>;
  updatedByGT: InputMaybe<Scalars['String']['input']>;
  updatedByGTE: InputMaybe<Scalars['String']['input']>;
  updatedByHasPrefix: InputMaybe<Scalars['String']['input']>;
  updatedByHasSuffix: InputMaybe<Scalars['String']['input']>;
  updatedByIn: InputMaybe<Array<Scalars['String']['input']>>;
  updatedByIsNil: InputMaybe<Scalars['Boolean']['input']>;
  updatedByLT: InputMaybe<Scalars['String']['input']>;
  updatedByLTE: InputMaybe<Scalars['String']['input']>;
  updatedByNEQ: InputMaybe<Scalars['String']['input']>;
  updatedByNotIn: InputMaybe<Array<Scalars['String']['input']>>;
  updatedByNotNil: InputMaybe<Scalars['Boolean']['input']>;
}

/** Ordering options for Integration connections */
export interface IntegrationOrder {
  /** The ordering direction. */
  direction: OrderDirection;
  /** The field by which to order Integrations. */
  field: IntegrationOrderField;
}

/** Properties by which Integration connections can be ordered. */
export enum IntegrationOrderField {
  kind = 'kind',
  name = 'name'
}

/**
 * IntegrationWhereInput is used for filtering Integration objects.
 * Input was generated by ent.
 */
export interface IntegrationWhereInput {
  and: InputMaybe<Array<IntegrationWhereInput>>;
  /** created_at field predicates */
  createdAt: InputMaybe<Scalars['Time']['input']>;
  createdAtGT: InputMaybe<Scalars['Time']['input']>;
  createdAtGTE: InputMaybe<Scalars['Time']['input']>;
  createdAtIn: InputMaybe<Array<Scalars['Time']['input']>>;
  createdAtLT: InputMaybe<Scalars['Time']['input']>;
  createdAtLTE: InputMaybe<Scalars['Time']['input']>;
  createdAtNEQ: InputMaybe<Scalars['Time']['input']>;
  createdAtNotIn: InputMaybe<Array<Scalars['Time']['input']>>;
  /** created_by field predicates */
  createdBy: InputMaybe<Scalars['String']['input']>;
  createdByContains: InputMaybe<Scalars['String']['input']>;
  createdByContainsFold: InputMaybe<Scalars['String']['input']>;
  createdByEqualFold: InputMaybe<Scalars['String']['input']>;
  createdByGT: InputMaybe<Scalars['String']['input']>;
  createdByGTE: InputMaybe<Scalars['String']['input']>;
  createdByHasPrefix: InputMaybe<Scalars['String']['input']>;
  createdByHasSuffix: InputMaybe<Scalars['String']['input']>;
  createdByIn: InputMaybe<Array<Scalars['String']['input']>>;
  createdByIsNil: InputMaybe<Scalars['Boolean']['input']>;
  createdByLT: InputMaybe<Scalars['String']['input']>;
  createdByLTE: InputMaybe<Scalars['String']['input']>;
  createdByNEQ: InputMaybe<Scalars['String']['input']>;
  createdByNotIn: InputMaybe<Array<Scalars['String']['input']>>;
  createdByNotNil: InputMaybe<Scalars['Boolean']['input']>;
  /** deleted_at field predicates */
  deletedAt: InputMaybe<Scalars['Time']['input']>;
  deletedAtGT: InputMaybe<Scalars['Time']['input']>;
  deletedAtGTE: InputMaybe<Scalars['Time']['input']>;
  deletedAtIn: InputMaybe<Array<Scalars['Time']['input']>>;
  deletedAtIsNil: InputMaybe<Scalars['Boolean']['input']>;
  deletedAtLT: InputMaybe<Scalars['Time']['input']>;
  deletedAtLTE: InputMaybe<Scalars['Time']['input']>;
  deletedAtNEQ: InputMaybe<Scalars['Time']['input']>;
  deletedAtNotIn: InputMaybe<Array<Scalars['Time']['input']>>;
  deletedAtNotNil: InputMaybe<Scalars['Boolean']['input']>;
  /** deleted_by field predicates */
  deletedBy: InputMaybe<Scalars['String']['input']>;
  deletedByContains: InputMaybe<Scalars['String']['input']>;
  deletedByContainsFold: InputMaybe<Scalars['String']['input']>;
  deletedByEqualFold: InputMaybe<Scalars['String']['input']>;
  deletedByGT: InputMaybe<Scalars['String']['input']>;
  deletedByGTE: InputMaybe<Scalars['String']['input']>;
  deletedByHasPrefix: InputMaybe<Scalars['String']['input']>;
  deletedByHasSuffix: InputMaybe<Scalars['String']['input']>;
  deletedByIn: InputMaybe<Array<Scalars['String']['input']>>;
  deletedByIsNil: InputMaybe<Scalars['Boolean']['input']>;
  deletedByLT: InputMaybe<Scalars['String']['input']>;
  deletedByLTE: InputMaybe<Scalars['String']['input']>;
  deletedByNEQ: InputMaybe<Scalars['String']['input']>;
  deletedByNotIn: InputMaybe<Array<Scalars['String']['input']>>;
  deletedByNotNil: InputMaybe<Scalars['Boolean']['input']>;
  /** owner edge predicates */
  hasOwner: InputMaybe<Scalars['Boolean']['input']>;
  hasOwnerWith: InputMaybe<Array<OrganizationWhereInput>>;
  /** id field predicates */
  id: InputMaybe<Scalars['ID']['input']>;
  idContainsFold: InputMaybe<Scalars['ID']['input']>;
  idEqualFold: InputMaybe<Scalars['ID']['input']>;
  idGT: InputMaybe<Scalars['ID']['input']>;
  idGTE: InputMaybe<Scalars['ID']['input']>;
  idIn: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT: InputMaybe<Scalars['ID']['input']>;
  idLTE: InputMaybe<Scalars['ID']['input']>;
  idNEQ: InputMaybe<Scalars['ID']['input']>;
  idNotIn: InputMaybe<Array<Scalars['ID']['input']>>;
  /** kind field predicates */
  kind: InputMaybe<Scalars['String']['input']>;
  kindContains: InputMaybe<Scalars['String']['input']>;
  kindContainsFold: InputMaybe<Scalars['String']['input']>;
  kindEqualFold: InputMaybe<Scalars['String']['input']>;
  kindGT: InputMaybe<Scalars['String']['input']>;
  kindGTE: InputMaybe<Scalars['String']['input']>;
  kindHasPrefix: InputMaybe<Scalars['String']['input']>;
  kindHasSuffix: InputMaybe<Scalars['String']['input']>;
  kindIn: InputMaybe<Array<Scalars['String']['input']>>;
  kindIsNil: InputMaybe<Scalars['Boolean']['input']>;
  kindLT: InputMaybe<Scalars['String']['input']>;
  kindLTE: InputMaybe<Scalars['String']['input']>;
  kindNEQ: InputMaybe<Scalars['String']['input']>;
  kindNotIn: InputMaybe<Array<Scalars['String']['input']>>;
  kindNotNil: InputMaybe<Scalars['Boolean']['input']>;
  /** name field predicates */
  name: InputMaybe<Scalars['String']['input']>;
  nameContains: InputMaybe<Scalars['String']['input']>;
  nameContainsFold: InputMaybe<Scalars['String']['input']>;
  nameEqualFold: InputMaybe<Scalars['String']['input']>;
  nameGT: InputMaybe<Scalars['String']['input']>;
  nameGTE: InputMaybe<Scalars['String']['input']>;
  nameHasPrefix: InputMaybe<Scalars['String']['input']>;
  nameHasSuffix: InputMaybe<Scalars['String']['input']>;
  nameIn: InputMaybe<Array<Scalars['String']['input']>>;
  nameLT: InputMaybe<Scalars['String']['input']>;
  nameLTE: InputMaybe<Scalars['String']['input']>;
  nameNEQ: InputMaybe<Scalars['String']['input']>;
  nameNotIn: InputMaybe<Array<Scalars['String']['input']>>;
  not: InputMaybe<IntegrationWhereInput>;
  or: InputMaybe<Array<IntegrationWhereInput>>;
  /** secret_name field predicates */
  secretName: InputMaybe<Scalars['String']['input']>;
  secretNameContains: InputMaybe<Scalars['String']['input']>;
  secretNameContainsFold: InputMaybe<Scalars['String']['input']>;
  secretNameEqualFold: InputMaybe<Scalars['String']['input']>;
  secretNameGT: InputMaybe<Scalars['String']['input']>;
  secretNameGTE: InputMaybe<Scalars['String']['input']>;
  secretNameHasPrefix: InputMaybe<Scalars['String']['input']>;
  secretNameHasSuffix: InputMaybe<Scalars['String']['input']>;
  secretNameIn: InputMaybe<Array<Scalars['String']['input']>>;
  secretNameLT: InputMaybe<Scalars['String']['input']>;
  secretNameLTE: InputMaybe<Scalars['String']['input']>;
  secretNameNEQ: InputMaybe<Scalars['String']['input']>;
  secretNameNotIn: InputMaybe<Array<Scalars['String']['input']>>;
  /** updated_at field predicates */
  updatedAt: InputMaybe<Scalars['Time']['input']>;
  updatedAtGT: InputMaybe<Scalars['Time']['input']>;
  updatedAtGTE: InputMaybe<Scalars['Time']['input']>;
  updatedAtIn: InputMaybe<Array<Scalars['Time']['input']>>;
  updatedAtLT: InputMaybe<Scalars['Time']['input']>;
  updatedAtLTE: InputMaybe<Scalars['Time']['input']>;
  updatedAtNEQ: InputMaybe<Scalars['Time']['input']>;
  updatedAtNotIn: InputMaybe<Array<Scalars['Time']['input']>>;
  /** updated_by field predicates */
  updatedBy: InputMaybe<Scalars['String']['input']>;
  updatedByContains: InputMaybe<Scalars['String']['input']>;
  updatedByContainsFold: InputMaybe<Scalars['String']['input']>;
  updatedByEqualFold: InputMaybe<Scalars['String']['input']>;
  updatedByGT: InputMaybe<Scalars['String']['input']>;
  updatedByGTE: InputMaybe<Scalars['String']['input']>;
  updatedByHasPrefix: InputMaybe<Scalars['String']['input']>;
  updatedByHasSuffix: InputMaybe<Scalars['String']['input']>;
  updatedByIn: InputMaybe<Array<Scalars['String']['input']>>;
  updatedByIsNil: InputMaybe<Scalars['Boolean']['input']>;
  updatedByLT: InputMaybe<Scalars['String']['input']>;
  updatedByLTE: InputMaybe<Scalars['String']['input']>;
  updatedByNEQ: InputMaybe<Scalars['String']['input']>;
  updatedByNotIn: InputMaybe<Array<Scalars['String']['input']>>;
  updatedByNotNil: InputMaybe<Scalars['Boolean']['input']>;
}

/**
 * OauthProviderWhereInput is used for filtering OauthProvider objects.
 * Input was generated by ent.
 */
export interface OauthProviderWhereInput {
  and: InputMaybe<Array<OauthProviderWhereInput>>;
  /** auth_style field predicates */
  authStyle: InputMaybe<Scalars['Int']['input']>;
  authStyleGT: InputMaybe<Scalars['Int']['input']>;
  authStyleGTE: InputMaybe<Scalars['Int']['input']>;
  authStyleIn: InputMaybe<Array<Scalars['Int']['input']>>;
  authStyleLT: InputMaybe<Scalars['Int']['input']>;
  authStyleLTE: InputMaybe<Scalars['Int']['input']>;
  authStyleNEQ: InputMaybe<Scalars['Int']['input']>;
  authStyleNotIn: InputMaybe<Array<Scalars['Int']['input']>>;
  /** auth_url field predicates */
  authURL: InputMaybe<Scalars['String']['input']>;
  authURLContains: InputMaybe<Scalars['String']['input']>;
  authURLContainsFold: InputMaybe<Scalars['String']['input']>;
  authURLEqualFold: InputMaybe<Scalars['String']['input']>;
  authURLGT: InputMaybe<Scalars['String']['input']>;
  authURLGTE: InputMaybe<Scalars['String']['input']>;
  authURLHasPrefix: InputMaybe<Scalars['String']['input']>;
  authURLHasSuffix: InputMaybe<Scalars['String']['input']>;
  authURLIn: InputMaybe<Array<Scalars['String']['input']>>;
  authURLLT: InputMaybe<Scalars['String']['input']>;
  authURLLTE: InputMaybe<Scalars['String']['input']>;
  authURLNEQ: InputMaybe<Scalars['String']['input']>;
  authURLNotIn: InputMaybe<Array<Scalars['String']['input']>>;
  /** client_id field predicates */
  clientID: InputMaybe<Scalars['String']['input']>;
  clientIDContains: InputMaybe<Scalars['String']['input']>;
  clientIDContainsFold: InputMaybe<Scalars['String']['input']>;
  clientIDEqualFold: InputMaybe<Scalars['String']['input']>;
  clientIDGT: InputMaybe<Scalars['String']['input']>;
  clientIDGTE: InputMaybe<Scalars['String']['input']>;
  clientIDHasPrefix: InputMaybe<Scalars['String']['input']>;
  clientIDHasSuffix: InputMaybe<Scalars['String']['input']>;
  clientIDIn: InputMaybe<Array<Scalars['String']['input']>>;
  clientIDLT: InputMaybe<Scalars['String']['input']>;
  clientIDLTE: InputMaybe<Scalars['String']['input']>;
  clientIDNEQ: InputMaybe<Scalars['String']['input']>;
  clientIDNotIn: InputMaybe<Array<Scalars['String']['input']>>;
  /** client_secret field predicates */
  clientSecret: InputMaybe<Scalars['String']['input']>;
  clientSecretContains: InputMaybe<Scalars['String']['input']>;
  clientSecretContainsFold: InputMaybe<Scalars['String']['input']>;
  clientSecretEqualFold: InputMaybe<Scalars['String']['input']>;
  clientSecretGT: InputMaybe<Scalars['String']['input']>;
  clientSecretGTE: InputMaybe<Scalars['String']['input']>;
  clientSecretHasPrefix: InputMaybe<Scalars['String']['input']>;
  clientSecretHasSuffix: InputMaybe<Scalars['String']['input']>;
  clientSecretIn: InputMaybe<Array<Scalars['String']['input']>>;
  clientSecretLT: InputMaybe<Scalars['String']['input']>;
  clientSecretLTE: InputMaybe<Scalars['String']['input']>;
  clientSecretNEQ: InputMaybe<Scalars['String']['input']>;
  clientSecretNotIn: InputMaybe<Array<Scalars['String']['input']>>;
  /** created_at field predicates */
  createdAt: InputMaybe<Scalars['Time']['input']>;
  createdAtGT: InputMaybe<Scalars['Time']['input']>;
  createdAtGTE: InputMaybe<Scalars['Time']['input']>;
  createdAtIn: InputMaybe<Array<Scalars['Time']['input']>>;
  createdAtLT: InputMaybe<Scalars['Time']['input']>;
  createdAtLTE: InputMaybe<Scalars['Time']['input']>;
  createdAtNEQ: InputMaybe<Scalars['Time']['input']>;
  createdAtNotIn: InputMaybe<Array<Scalars['Time']['input']>>;
  /** created_by field predicates */
  createdBy: InputMaybe<Scalars['String']['input']>;
  createdByContains: InputMaybe<Scalars['String']['input']>;
  createdByContainsFold: InputMaybe<Scalars['String']['input']>;
  createdByEqualFold: InputMaybe<Scalars['String']['input']>;
  createdByGT: InputMaybe<Scalars['String']['input']>;
  createdByGTE: InputMaybe<Scalars['String']['input']>;
  createdByHasPrefix: InputMaybe<Scalars['String']['input']>;
  createdByHasSuffix: InputMaybe<Scalars['String']['input']>;
  createdByIn: InputMaybe<Array<Scalars['String']['input']>>;
  createdByIsNil: InputMaybe<Scalars['Boolean']['input']>;
  createdByLT: InputMaybe<Scalars['String']['input']>;
  createdByLTE: InputMaybe<Scalars['String']['input']>;
  createdByNEQ: InputMaybe<Scalars['String']['input']>;
  createdByNotIn: InputMaybe<Array<Scalars['String']['input']>>;
  createdByNotNil: InputMaybe<Scalars['Boolean']['input']>;
  /** deleted_at field predicates */
  deletedAt: InputMaybe<Scalars['Time']['input']>;
  deletedAtGT: InputMaybe<Scalars['Time']['input']>;
  deletedAtGTE: InputMaybe<Scalars['Time']['input']>;
  deletedAtIn: InputMaybe<Array<Scalars['Time']['input']>>;
  deletedAtIsNil: InputMaybe<Scalars['Boolean']['input']>;
  deletedAtLT: InputMaybe<Scalars['Time']['input']>;
  deletedAtLTE: InputMaybe<Scalars['Time']['input']>;
  deletedAtNEQ: InputMaybe<Scalars['Time']['input']>;
  deletedAtNotIn: InputMaybe<Array<Scalars['Time']['input']>>;
  deletedAtNotNil: InputMaybe<Scalars['Boolean']['input']>;
  /** deleted_by field predicates */
  deletedBy: InputMaybe<Scalars['String']['input']>;
  deletedByContains: InputMaybe<Scalars['String']['input']>;
  deletedByContainsFold: InputMaybe<Scalars['String']['input']>;
  deletedByEqualFold: InputMaybe<Scalars['String']['input']>;
  deletedByGT: InputMaybe<Scalars['String']['input']>;
  deletedByGTE: InputMaybe<Scalars['String']['input']>;
  deletedByHasPrefix: InputMaybe<Scalars['String']['input']>;
  deletedByHasSuffix: InputMaybe<Scalars['String']['input']>;
  deletedByIn: InputMaybe<Array<Scalars['String']['input']>>;
  deletedByIsNil: InputMaybe<Scalars['Boolean']['input']>;
  deletedByLT: InputMaybe<Scalars['String']['input']>;
  deletedByLTE: InputMaybe<Scalars['String']['input']>;
  deletedByNEQ: InputMaybe<Scalars['String']['input']>;
  deletedByNotIn: InputMaybe<Array<Scalars['String']['input']>>;
  deletedByNotNil: InputMaybe<Scalars['Boolean']['input']>;
  /** owner edge predicates */
  hasOwner: InputMaybe<Scalars['Boolean']['input']>;
  hasOwnerWith: InputMaybe<Array<OrganizationWhereInput>>;
  /** id field predicates */
  id: InputMaybe<Scalars['ID']['input']>;
  idContainsFold: InputMaybe<Scalars['ID']['input']>;
  idEqualFold: InputMaybe<Scalars['ID']['input']>;
  idGT: InputMaybe<Scalars['ID']['input']>;
  idGTE: InputMaybe<Scalars['ID']['input']>;
  idIn: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT: InputMaybe<Scalars['ID']['input']>;
  idLTE: InputMaybe<Scalars['ID']['input']>;
  idNEQ: InputMaybe<Scalars['ID']['input']>;
  idNotIn: InputMaybe<Array<Scalars['ID']['input']>>;
  /** info_url field predicates */
  infoURL: InputMaybe<Scalars['String']['input']>;
  infoURLContains: InputMaybe<Scalars['String']['input']>;
  infoURLContainsFold: InputMaybe<Scalars['String']['input']>;
  infoURLEqualFold: InputMaybe<Scalars['String']['input']>;
  infoURLGT: InputMaybe<Scalars['String']['input']>;
  infoURLGTE: InputMaybe<Scalars['String']['input']>;
  infoURLHasPrefix: InputMaybe<Scalars['String']['input']>;
  infoURLHasSuffix: InputMaybe<Scalars['String']['input']>;
  infoURLIn: InputMaybe<Array<Scalars['String']['input']>>;
  infoURLLT: InputMaybe<Scalars['String']['input']>;
  infoURLLTE: InputMaybe<Scalars['String']['input']>;
  infoURLNEQ: InputMaybe<Scalars['String']['input']>;
  infoURLNotIn: InputMaybe<Array<Scalars['String']['input']>>;
  /** name field predicates */
  name: InputMaybe<Scalars['String']['input']>;
  nameContains: InputMaybe<Scalars['String']['input']>;
  nameContainsFold: InputMaybe<Scalars['String']['input']>;
  nameEqualFold: InputMaybe<Scalars['String']['input']>;
  nameGT: InputMaybe<Scalars['String']['input']>;
  nameGTE: InputMaybe<Scalars['String']['input']>;
  nameHasPrefix: InputMaybe<Scalars['String']['input']>;
  nameHasSuffix: InputMaybe<Scalars['String']['input']>;
  nameIn: InputMaybe<Array<Scalars['String']['input']>>;
  nameLT: InputMaybe<Scalars['String']['input']>;
  nameLTE: InputMaybe<Scalars['String']['input']>;
  nameNEQ: InputMaybe<Scalars['String']['input']>;
  nameNotIn: InputMaybe<Array<Scalars['String']['input']>>;
  not: InputMaybe<OauthProviderWhereInput>;
  or: InputMaybe<Array<OauthProviderWhereInput>>;
  /** redirect_url field predicates */
  redirectURL: InputMaybe<Scalars['String']['input']>;
  redirectURLContains: InputMaybe<Scalars['String']['input']>;
  redirectURLContainsFold: InputMaybe<Scalars['String']['input']>;
  redirectURLEqualFold: InputMaybe<Scalars['String']['input']>;
  redirectURLGT: InputMaybe<Scalars['String']['input']>;
  redirectURLGTE: InputMaybe<Scalars['String']['input']>;
  redirectURLHasPrefix: InputMaybe<Scalars['String']['input']>;
  redirectURLHasSuffix: InputMaybe<Scalars['String']['input']>;
  redirectURLIn: InputMaybe<Array<Scalars['String']['input']>>;
  redirectURLLT: InputMaybe<Scalars['String']['input']>;
  redirectURLLTE: InputMaybe<Scalars['String']['input']>;
  redirectURLNEQ: InputMaybe<Scalars['String']['input']>;
  redirectURLNotIn: InputMaybe<Array<Scalars['String']['input']>>;
  /** scopes field predicates */
  scopes: InputMaybe<Scalars['String']['input']>;
  scopesContains: InputMaybe<Scalars['String']['input']>;
  scopesContainsFold: InputMaybe<Scalars['String']['input']>;
  scopesEqualFold: InputMaybe<Scalars['String']['input']>;
  scopesGT: InputMaybe<Scalars['String']['input']>;
  scopesGTE: InputMaybe<Scalars['String']['input']>;
  scopesHasPrefix: InputMaybe<Scalars['String']['input']>;
  scopesHasSuffix: InputMaybe<Scalars['String']['input']>;
  scopesIn: InputMaybe<Array<Scalars['String']['input']>>;
  scopesLT: InputMaybe<Scalars['String']['input']>;
  scopesLTE: InputMaybe<Scalars['String']['input']>;
  scopesNEQ: InputMaybe<Scalars['String']['input']>;
  scopesNotIn: InputMaybe<Array<Scalars['String']['input']>>;
  /** token_url field predicates */
  tokenURL: InputMaybe<Scalars['String']['input']>;
  tokenURLContains: InputMaybe<Scalars['String']['input']>;
  tokenURLContainsFold: InputMaybe<Scalars['String']['input']>;
  tokenURLEqualFold: InputMaybe<Scalars['String']['input']>;
  tokenURLGT: InputMaybe<Scalars['String']['input']>;
  tokenURLGTE: InputMaybe<Scalars['String']['input']>;
  tokenURLHasPrefix: InputMaybe<Scalars['String']['input']>;
  tokenURLHasSuffix: InputMaybe<Scalars['String']['input']>;
  tokenURLIn: InputMaybe<Array<Scalars['String']['input']>>;
  tokenURLLT: InputMaybe<Scalars['String']['input']>;
  tokenURLLTE: InputMaybe<Scalars['String']['input']>;
  tokenURLNEQ: InputMaybe<Scalars['String']['input']>;
  tokenURLNotIn: InputMaybe<Array<Scalars['String']['input']>>;
  /** updated_at field predicates */
  updatedAt: InputMaybe<Scalars['Time']['input']>;
  updatedAtGT: InputMaybe<Scalars['Time']['input']>;
  updatedAtGTE: InputMaybe<Scalars['Time']['input']>;
  updatedAtIn: InputMaybe<Array<Scalars['Time']['input']>>;
  updatedAtLT: InputMaybe<Scalars['Time']['input']>;
  updatedAtLTE: InputMaybe<Scalars['Time']['input']>;
  updatedAtNEQ: InputMaybe<Scalars['Time']['input']>;
  updatedAtNotIn: InputMaybe<Array<Scalars['Time']['input']>>;
  /** updated_by field predicates */
  updatedBy: InputMaybe<Scalars['String']['input']>;
  updatedByContains: InputMaybe<Scalars['String']['input']>;
  updatedByContainsFold: InputMaybe<Scalars['String']['input']>;
  updatedByEqualFold: InputMaybe<Scalars['String']['input']>;
  updatedByGT: InputMaybe<Scalars['String']['input']>;
  updatedByGTE: InputMaybe<Scalars['String']['input']>;
  updatedByHasPrefix: InputMaybe<Scalars['String']['input']>;
  updatedByHasSuffix: InputMaybe<Scalars['String']['input']>;
  updatedByIn: InputMaybe<Array<Scalars['String']['input']>>;
  updatedByIsNil: InputMaybe<Scalars['Boolean']['input']>;
  updatedByLT: InputMaybe<Scalars['String']['input']>;
  updatedByLTE: InputMaybe<Scalars['String']['input']>;
  updatedByNEQ: InputMaybe<Scalars['String']['input']>;
  updatedByNotIn: InputMaybe<Array<Scalars['String']['input']>>;
  updatedByNotNil: InputMaybe<Scalars['Boolean']['input']>;
}

/**
 * OhAuthTooTokenWhereInput is used for filtering OhAuthTooToken objects.
 * Input was generated by ent.
 */
export interface OhAuthTooTokenWhereInput {
  and: InputMaybe<Array<OhAuthTooTokenWhereInput>>;
  /** claims_email field predicates */
  claimsEmail: InputMaybe<Scalars['String']['input']>;
  claimsEmailContains: InputMaybe<Scalars['String']['input']>;
  claimsEmailContainsFold: InputMaybe<Scalars['String']['input']>;
  claimsEmailEqualFold: InputMaybe<Scalars['String']['input']>;
  claimsEmailGT: InputMaybe<Scalars['String']['input']>;
  claimsEmailGTE: InputMaybe<Scalars['String']['input']>;
  claimsEmailHasPrefix: InputMaybe<Scalars['String']['input']>;
  claimsEmailHasSuffix: InputMaybe<Scalars['String']['input']>;
  claimsEmailIn: InputMaybe<Array<Scalars['String']['input']>>;
  claimsEmailLT: InputMaybe<Scalars['String']['input']>;
  claimsEmailLTE: InputMaybe<Scalars['String']['input']>;
  claimsEmailNEQ: InputMaybe<Scalars['String']['input']>;
  claimsEmailNotIn: InputMaybe<Array<Scalars['String']['input']>>;
  /** claims_email_verified field predicates */
  claimsEmailVerified: InputMaybe<Scalars['Boolean']['input']>;
  claimsEmailVerifiedNEQ: InputMaybe<Scalars['Boolean']['input']>;
  /** claims_preferred_username field predicates */
  claimsPreferredUsername: InputMaybe<Scalars['String']['input']>;
  claimsPreferredUsernameContains: InputMaybe<Scalars['String']['input']>;
  claimsPreferredUsernameContainsFold: InputMaybe<Scalars['String']['input']>;
  claimsPreferredUsernameEqualFold: InputMaybe<Scalars['String']['input']>;
  claimsPreferredUsernameGT: InputMaybe<Scalars['String']['input']>;
  claimsPreferredUsernameGTE: InputMaybe<Scalars['String']['input']>;
  claimsPreferredUsernameHasPrefix: InputMaybe<Scalars['String']['input']>;
  claimsPreferredUsernameHasSuffix: InputMaybe<Scalars['String']['input']>;
  claimsPreferredUsernameIn: InputMaybe<Array<Scalars['String']['input']>>;
  claimsPreferredUsernameLT: InputMaybe<Scalars['String']['input']>;
  claimsPreferredUsernameLTE: InputMaybe<Scalars['String']['input']>;
  claimsPreferredUsernameNEQ: InputMaybe<Scalars['String']['input']>;
  claimsPreferredUsernameNotIn: InputMaybe<Array<Scalars['String']['input']>>;
  /** claims_user_id field predicates */
  claimsUserID: InputMaybe<Scalars['String']['input']>;
  claimsUserIDContains: InputMaybe<Scalars['String']['input']>;
  claimsUserIDContainsFold: InputMaybe<Scalars['String']['input']>;
  claimsUserIDEqualFold: InputMaybe<Scalars['String']['input']>;
  claimsUserIDGT: InputMaybe<Scalars['String']['input']>;
  claimsUserIDGTE: InputMaybe<Scalars['String']['input']>;
  claimsUserIDHasPrefix: InputMaybe<Scalars['String']['input']>;
  claimsUserIDHasSuffix: InputMaybe<Scalars['String']['input']>;
  claimsUserIDIn: InputMaybe<Array<Scalars['String']['input']>>;
  claimsUserIDLT: InputMaybe<Scalars['String']['input']>;
  claimsUserIDLTE: InputMaybe<Scalars['String']['input']>;
  claimsUserIDNEQ: InputMaybe<Scalars['String']['input']>;
  claimsUserIDNotIn: InputMaybe<Array<Scalars['String']['input']>>;
  /** claims_username field predicates */
  claimsUsername: InputMaybe<Scalars['String']['input']>;
  claimsUsernameContains: InputMaybe<Scalars['String']['input']>;
  claimsUsernameContainsFold: InputMaybe<Scalars['String']['input']>;
  claimsUsernameEqualFold: InputMaybe<Scalars['String']['input']>;
  claimsUsernameGT: InputMaybe<Scalars['String']['input']>;
  claimsUsernameGTE: InputMaybe<Scalars['String']['input']>;
  claimsUsernameHasPrefix: InputMaybe<Scalars['String']['input']>;
  claimsUsernameHasSuffix: InputMaybe<Scalars['String']['input']>;
  claimsUsernameIn: InputMaybe<Array<Scalars['String']['input']>>;
  claimsUsernameLT: InputMaybe<Scalars['String']['input']>;
  claimsUsernameLTE: InputMaybe<Scalars['String']['input']>;
  claimsUsernameNEQ: InputMaybe<Scalars['String']['input']>;
  claimsUsernameNotIn: InputMaybe<Array<Scalars['String']['input']>>;
  /** client_id field predicates */
  clientID: InputMaybe<Scalars['String']['input']>;
  clientIDContains: InputMaybe<Scalars['String']['input']>;
  clientIDContainsFold: InputMaybe<Scalars['String']['input']>;
  clientIDEqualFold: InputMaybe<Scalars['String']['input']>;
  clientIDGT: InputMaybe<Scalars['String']['input']>;
  clientIDGTE: InputMaybe<Scalars['String']['input']>;
  clientIDHasPrefix: InputMaybe<Scalars['String']['input']>;
  clientIDHasSuffix: InputMaybe<Scalars['String']['input']>;
  clientIDIn: InputMaybe<Array<Scalars['String']['input']>>;
  clientIDLT: InputMaybe<Scalars['String']['input']>;
  clientIDLTE: InputMaybe<Scalars['String']['input']>;
  clientIDNEQ: InputMaybe<Scalars['String']['input']>;
  clientIDNotIn: InputMaybe<Array<Scalars['String']['input']>>;
  /** connector_id field predicates */
  connectorID: InputMaybe<Scalars['String']['input']>;
  connectorIDContains: InputMaybe<Scalars['String']['input']>;
  connectorIDContainsFold: InputMaybe<Scalars['String']['input']>;
  connectorIDEqualFold: InputMaybe<Scalars['String']['input']>;
  connectorIDGT: InputMaybe<Scalars['String']['input']>;
  connectorIDGTE: InputMaybe<Scalars['String']['input']>;
  connectorIDHasPrefix: InputMaybe<Scalars['String']['input']>;
  connectorIDHasSuffix: InputMaybe<Scalars['String']['input']>;
  connectorIDIn: InputMaybe<Array<Scalars['String']['input']>>;
  connectorIDLT: InputMaybe<Scalars['String']['input']>;
  connectorIDLTE: InputMaybe<Scalars['String']['input']>;
  connectorIDNEQ: InputMaybe<Scalars['String']['input']>;
  connectorIDNotIn: InputMaybe<Array<Scalars['String']['input']>>;
  /** id field predicates */
  id: InputMaybe<Scalars['ID']['input']>;
  idContainsFold: InputMaybe<Scalars['ID']['input']>;
  idEqualFold: InputMaybe<Scalars['ID']['input']>;
  idGT: InputMaybe<Scalars['ID']['input']>;
  idGTE: InputMaybe<Scalars['ID']['input']>;
  idIn: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT: InputMaybe<Scalars['ID']['input']>;
  idLTE: InputMaybe<Scalars['ID']['input']>;
  idNEQ: InputMaybe<Scalars['ID']['input']>;
  idNotIn: InputMaybe<Array<Scalars['ID']['input']>>;
  /** last_used field predicates */
  lastUsed: InputMaybe<Scalars['Time']['input']>;
  lastUsedGT: InputMaybe<Scalars['Time']['input']>;
  lastUsedGTE: InputMaybe<Scalars['Time']['input']>;
  lastUsedIn: InputMaybe<Array<Scalars['Time']['input']>>;
  lastUsedLT: InputMaybe<Scalars['Time']['input']>;
  lastUsedLTE: InputMaybe<Scalars['Time']['input']>;
  lastUsedNEQ: InputMaybe<Scalars['Time']['input']>;
  lastUsedNotIn: InputMaybe<Array<Scalars['Time']['input']>>;
  /** nonce field predicates */
  nonce: InputMaybe<Scalars['String']['input']>;
  nonceContains: InputMaybe<Scalars['String']['input']>;
  nonceContainsFold: InputMaybe<Scalars['String']['input']>;
  nonceEqualFold: InputMaybe<Scalars['String']['input']>;
  nonceGT: InputMaybe<Scalars['String']['input']>;
  nonceGTE: InputMaybe<Scalars['String']['input']>;
  nonceHasPrefix: InputMaybe<Scalars['String']['input']>;
  nonceHasSuffix: InputMaybe<Scalars['String']['input']>;
  nonceIn: InputMaybe<Array<Scalars['String']['input']>>;
  nonceLT: InputMaybe<Scalars['String']['input']>;
  nonceLTE: InputMaybe<Scalars['String']['input']>;
  nonceNEQ: InputMaybe<Scalars['String']['input']>;
  nonceNotIn: InputMaybe<Array<Scalars['String']['input']>>;
  not: InputMaybe<OhAuthTooTokenWhereInput>;
  or: InputMaybe<Array<OhAuthTooTokenWhereInput>>;
}

/** Possible directions in which to order a list of items when provided an `orderBy` argument. */
export enum OrderDirection {
  /** Specifies an ascending order for a given `orderBy` argument. */
  ASC = 'ASC',
  /** Specifies a descending order for a given `orderBy` argument. */
  DESC = 'DESC'
}

/** OrgMembershipRole is enum for the field role */
export enum OrgMembershipRole {
  ADMIN = 'ADMIN',
  MEMBER = 'MEMBER',
  OWNER = 'OWNER'
}

/**
 * OrgMembershipWhereInput is used for filtering OrgMembership objects.
 * Input was generated by ent.
 */
export interface OrgMembershipWhereInput {
  and: InputMaybe<Array<OrgMembershipWhereInput>>;
  /** created_at field predicates */
  createdAt: InputMaybe<Scalars['Time']['input']>;
  createdAtGT: InputMaybe<Scalars['Time']['input']>;
  createdAtGTE: InputMaybe<Scalars['Time']['input']>;
  createdAtIn: InputMaybe<Array<Scalars['Time']['input']>>;
  createdAtLT: InputMaybe<Scalars['Time']['input']>;
  createdAtLTE: InputMaybe<Scalars['Time']['input']>;
  createdAtNEQ: InputMaybe<Scalars['Time']['input']>;
  createdAtNotIn: InputMaybe<Array<Scalars['Time']['input']>>;
  /** created_by field predicates */
  createdBy: InputMaybe<Scalars['String']['input']>;
  createdByContains: InputMaybe<Scalars['String']['input']>;
  createdByContainsFold: InputMaybe<Scalars['String']['input']>;
  createdByEqualFold: InputMaybe<Scalars['String']['input']>;
  createdByGT: InputMaybe<Scalars['String']['input']>;
  createdByGTE: InputMaybe<Scalars['String']['input']>;
  createdByHasPrefix: InputMaybe<Scalars['String']['input']>;
  createdByHasSuffix: InputMaybe<Scalars['String']['input']>;
  createdByIn: InputMaybe<Array<Scalars['String']['input']>>;
  createdByIsNil: InputMaybe<Scalars['Boolean']['input']>;
  createdByLT: InputMaybe<Scalars['String']['input']>;
  createdByLTE: InputMaybe<Scalars['String']['input']>;
  createdByNEQ: InputMaybe<Scalars['String']['input']>;
  createdByNotIn: InputMaybe<Array<Scalars['String']['input']>>;
  createdByNotNil: InputMaybe<Scalars['Boolean']['input']>;
  /** deleted_at field predicates */
  deletedAt: InputMaybe<Scalars['Time']['input']>;
  deletedAtGT: InputMaybe<Scalars['Time']['input']>;
  deletedAtGTE: InputMaybe<Scalars['Time']['input']>;
  deletedAtIn: InputMaybe<Array<Scalars['Time']['input']>>;
  deletedAtIsNil: InputMaybe<Scalars['Boolean']['input']>;
  deletedAtLT: InputMaybe<Scalars['Time']['input']>;
  deletedAtLTE: InputMaybe<Scalars['Time']['input']>;
  deletedAtNEQ: InputMaybe<Scalars['Time']['input']>;
  deletedAtNotIn: InputMaybe<Array<Scalars['Time']['input']>>;
  deletedAtNotNil: InputMaybe<Scalars['Boolean']['input']>;
  /** deleted_by field predicates */
  deletedBy: InputMaybe<Scalars['String']['input']>;
  deletedByContains: InputMaybe<Scalars['String']['input']>;
  deletedByContainsFold: InputMaybe<Scalars['String']['input']>;
  deletedByEqualFold: InputMaybe<Scalars['String']['input']>;
  deletedByGT: InputMaybe<Scalars['String']['input']>;
  deletedByGTE: InputMaybe<Scalars['String']['input']>;
  deletedByHasPrefix: InputMaybe<Scalars['String']['input']>;
  deletedByHasSuffix: InputMaybe<Scalars['String']['input']>;
  deletedByIn: InputMaybe<Array<Scalars['String']['input']>>;
  deletedByIsNil: InputMaybe<Scalars['Boolean']['input']>;
  deletedByLT: InputMaybe<Scalars['String']['input']>;
  deletedByLTE: InputMaybe<Scalars['String']['input']>;
  deletedByNEQ: InputMaybe<Scalars['String']['input']>;
  deletedByNotIn: InputMaybe<Array<Scalars['String']['input']>>;
  deletedByNotNil: InputMaybe<Scalars['Boolean']['input']>;
  /** id field predicates */
  id: InputMaybe<Scalars['ID']['input']>;
  idContainsFold: InputMaybe<Scalars['ID']['input']>;
  idEqualFold: InputMaybe<Scalars['ID']['input']>;
  idGT: InputMaybe<Scalars['ID']['input']>;
  idGTE: InputMaybe<Scalars['ID']['input']>;
  idIn: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT: InputMaybe<Scalars['ID']['input']>;
  idLTE: InputMaybe<Scalars['ID']['input']>;
  idNEQ: InputMaybe<Scalars['ID']['input']>;
  idNotIn: InputMaybe<Array<Scalars['ID']['input']>>;
  not: InputMaybe<OrgMembershipWhereInput>;
  or: InputMaybe<Array<OrgMembershipWhereInput>>;
  orgID: InputMaybe<Scalars['String']['input']>;
  /** role field predicates */
  role: InputMaybe<OrgMembershipRole>;
  roleIn: InputMaybe<Array<OrgMembershipRole>>;
  roleNEQ: InputMaybe<OrgMembershipRole>;
  roleNotIn: InputMaybe<Array<OrgMembershipRole>>;
  /** updated_at field predicates */
  updatedAt: InputMaybe<Scalars['Time']['input']>;
  updatedAtGT: InputMaybe<Scalars['Time']['input']>;
  updatedAtGTE: InputMaybe<Scalars['Time']['input']>;
  updatedAtIn: InputMaybe<Array<Scalars['Time']['input']>>;
  updatedAtLT: InputMaybe<Scalars['Time']['input']>;
  updatedAtLTE: InputMaybe<Scalars['Time']['input']>;
  updatedAtNEQ: InputMaybe<Scalars['Time']['input']>;
  updatedAtNotIn: InputMaybe<Array<Scalars['Time']['input']>>;
  /** updated_by field predicates */
  updatedBy: InputMaybe<Scalars['String']['input']>;
  updatedByContains: InputMaybe<Scalars['String']['input']>;
  updatedByContainsFold: InputMaybe<Scalars['String']['input']>;
  updatedByEqualFold: InputMaybe<Scalars['String']['input']>;
  updatedByGT: InputMaybe<Scalars['String']['input']>;
  updatedByGTE: InputMaybe<Scalars['String']['input']>;
  updatedByHasPrefix: InputMaybe<Scalars['String']['input']>;
  updatedByHasSuffix: InputMaybe<Scalars['String']['input']>;
  updatedByIn: InputMaybe<Array<Scalars['String']['input']>>;
  updatedByIsNil: InputMaybe<Scalars['Boolean']['input']>;
  updatedByLT: InputMaybe<Scalars['String']['input']>;
  updatedByLTE: InputMaybe<Scalars['String']['input']>;
  updatedByNEQ: InputMaybe<Scalars['String']['input']>;
  updatedByNotIn: InputMaybe<Array<Scalars['String']['input']>>;
  updatedByNotNil: InputMaybe<Scalars['Boolean']['input']>;
  userID: InputMaybe<Scalars['String']['input']>;
}

/** Ordering options for Organization connections */
export interface OrganizationOrder {
  /** The ordering direction. */
  direction: OrderDirection;
  /** The field by which to order Organizations. */
  field: OrganizationOrderField;
}

/** Properties by which Organization connections can be ordered. */
export enum OrganizationOrderField {
  display_name = 'display_name',
  name = 'name'
}

/**
 * OrganizationSettingWhereInput is used for filtering OrganizationSetting objects.
 * Input was generated by ent.
 */
export interface OrganizationSettingWhereInput {
  and: InputMaybe<Array<OrganizationSettingWhereInput>>;
  /** billing_address field predicates */
  billingAddress: InputMaybe<Scalars['String']['input']>;
  billingAddressContains: InputMaybe<Scalars['String']['input']>;
  billingAddressContainsFold: InputMaybe<Scalars['String']['input']>;
  billingAddressEqualFold: InputMaybe<Scalars['String']['input']>;
  billingAddressGT: InputMaybe<Scalars['String']['input']>;
  billingAddressGTE: InputMaybe<Scalars['String']['input']>;
  billingAddressHasPrefix: InputMaybe<Scalars['String']['input']>;
  billingAddressHasSuffix: InputMaybe<Scalars['String']['input']>;
  billingAddressIn: InputMaybe<Array<Scalars['String']['input']>>;
  billingAddressIsNil: InputMaybe<Scalars['Boolean']['input']>;
  billingAddressLT: InputMaybe<Scalars['String']['input']>;
  billingAddressLTE: InputMaybe<Scalars['String']['input']>;
  billingAddressNEQ: InputMaybe<Scalars['String']['input']>;
  billingAddressNotIn: InputMaybe<Array<Scalars['String']['input']>>;
  billingAddressNotNil: InputMaybe<Scalars['Boolean']['input']>;
  /** billing_contact field predicates */
  billingContact: InputMaybe<Scalars['String']['input']>;
  billingContactContains: InputMaybe<Scalars['String']['input']>;
  billingContactContainsFold: InputMaybe<Scalars['String']['input']>;
  billingContactEqualFold: InputMaybe<Scalars['String']['input']>;
  billingContactGT: InputMaybe<Scalars['String']['input']>;
  billingContactGTE: InputMaybe<Scalars['String']['input']>;
  billingContactHasPrefix: InputMaybe<Scalars['String']['input']>;
  billingContactHasSuffix: InputMaybe<Scalars['String']['input']>;
  billingContactIn: InputMaybe<Array<Scalars['String']['input']>>;
  billingContactIsNil: InputMaybe<Scalars['Boolean']['input']>;
  billingContactLT: InputMaybe<Scalars['String']['input']>;
  billingContactLTE: InputMaybe<Scalars['String']['input']>;
  billingContactNEQ: InputMaybe<Scalars['String']['input']>;
  billingContactNotIn: InputMaybe<Array<Scalars['String']['input']>>;
  billingContactNotNil: InputMaybe<Scalars['Boolean']['input']>;
  /** billing_email field predicates */
  billingEmail: InputMaybe<Scalars['String']['input']>;
  billingEmailContains: InputMaybe<Scalars['String']['input']>;
  billingEmailContainsFold: InputMaybe<Scalars['String']['input']>;
  billingEmailEqualFold: InputMaybe<Scalars['String']['input']>;
  billingEmailGT: InputMaybe<Scalars['String']['input']>;
  billingEmailGTE: InputMaybe<Scalars['String']['input']>;
  billingEmailHasPrefix: InputMaybe<Scalars['String']['input']>;
  billingEmailHasSuffix: InputMaybe<Scalars['String']['input']>;
  billingEmailIn: InputMaybe<Array<Scalars['String']['input']>>;
  billingEmailIsNil: InputMaybe<Scalars['Boolean']['input']>;
  billingEmailLT: InputMaybe<Scalars['String']['input']>;
  billingEmailLTE: InputMaybe<Scalars['String']['input']>;
  billingEmailNEQ: InputMaybe<Scalars['String']['input']>;
  billingEmailNotIn: InputMaybe<Array<Scalars['String']['input']>>;
  billingEmailNotNil: InputMaybe<Scalars['Boolean']['input']>;
  /** billing_phone field predicates */
  billingPhone: InputMaybe<Scalars['String']['input']>;
  billingPhoneContains: InputMaybe<Scalars['String']['input']>;
  billingPhoneContainsFold: InputMaybe<Scalars['String']['input']>;
  billingPhoneEqualFold: InputMaybe<Scalars['String']['input']>;
  billingPhoneGT: InputMaybe<Scalars['String']['input']>;
  billingPhoneGTE: InputMaybe<Scalars['String']['input']>;
  billingPhoneHasPrefix: InputMaybe<Scalars['String']['input']>;
  billingPhoneHasSuffix: InputMaybe<Scalars['String']['input']>;
  billingPhoneIn: InputMaybe<Array<Scalars['String']['input']>>;
  billingPhoneIsNil: InputMaybe<Scalars['Boolean']['input']>;
  billingPhoneLT: InputMaybe<Scalars['String']['input']>;
  billingPhoneLTE: InputMaybe<Scalars['String']['input']>;
  billingPhoneNEQ: InputMaybe<Scalars['String']['input']>;
  billingPhoneNotIn: InputMaybe<Array<Scalars['String']['input']>>;
  billingPhoneNotNil: InputMaybe<Scalars['Boolean']['input']>;
  /** created_at field predicates */
  createdAt: InputMaybe<Scalars['Time']['input']>;
  createdAtGT: InputMaybe<Scalars['Time']['input']>;
  createdAtGTE: InputMaybe<Scalars['Time']['input']>;
  createdAtIn: InputMaybe<Array<Scalars['Time']['input']>>;
  createdAtLT: InputMaybe<Scalars['Time']['input']>;
  createdAtLTE: InputMaybe<Scalars['Time']['input']>;
  createdAtNEQ: InputMaybe<Scalars['Time']['input']>;
  createdAtNotIn: InputMaybe<Array<Scalars['Time']['input']>>;
  /** created_by field predicates */
  createdBy: InputMaybe<Scalars['String']['input']>;
  createdByContains: InputMaybe<Scalars['String']['input']>;
  createdByContainsFold: InputMaybe<Scalars['String']['input']>;
  createdByEqualFold: InputMaybe<Scalars['String']['input']>;
  createdByGT: InputMaybe<Scalars['String']['input']>;
  createdByGTE: InputMaybe<Scalars['String']['input']>;
  createdByHasPrefix: InputMaybe<Scalars['String']['input']>;
  createdByHasSuffix: InputMaybe<Scalars['String']['input']>;
  createdByIn: InputMaybe<Array<Scalars['String']['input']>>;
  createdByIsNil: InputMaybe<Scalars['Boolean']['input']>;
  createdByLT: InputMaybe<Scalars['String']['input']>;
  createdByLTE: InputMaybe<Scalars['String']['input']>;
  createdByNEQ: InputMaybe<Scalars['String']['input']>;
  createdByNotIn: InputMaybe<Array<Scalars['String']['input']>>;
  createdByNotNil: InputMaybe<Scalars['Boolean']['input']>;
  /** deleted_at field predicates */
  deletedAt: InputMaybe<Scalars['Time']['input']>;
  deletedAtGT: InputMaybe<Scalars['Time']['input']>;
  deletedAtGTE: InputMaybe<Scalars['Time']['input']>;
  deletedAtIn: InputMaybe<Array<Scalars['Time']['input']>>;
  deletedAtIsNil: InputMaybe<Scalars['Boolean']['input']>;
  deletedAtLT: InputMaybe<Scalars['Time']['input']>;
  deletedAtLTE: InputMaybe<Scalars['Time']['input']>;
  deletedAtNEQ: InputMaybe<Scalars['Time']['input']>;
  deletedAtNotIn: InputMaybe<Array<Scalars['Time']['input']>>;
  deletedAtNotNil: InputMaybe<Scalars['Boolean']['input']>;
  /** deleted_by field predicates */
  deletedBy: InputMaybe<Scalars['String']['input']>;
  deletedByContains: InputMaybe<Scalars['String']['input']>;
  deletedByContainsFold: InputMaybe<Scalars['String']['input']>;
  deletedByEqualFold: InputMaybe<Scalars['String']['input']>;
  deletedByGT: InputMaybe<Scalars['String']['input']>;
  deletedByGTE: InputMaybe<Scalars['String']['input']>;
  deletedByHasPrefix: InputMaybe<Scalars['String']['input']>;
  deletedByHasSuffix: InputMaybe<Scalars['String']['input']>;
  deletedByIn: InputMaybe<Array<Scalars['String']['input']>>;
  deletedByIsNil: InputMaybe<Scalars['Boolean']['input']>;
  deletedByLT: InputMaybe<Scalars['String']['input']>;
  deletedByLTE: InputMaybe<Scalars['String']['input']>;
  deletedByNEQ: InputMaybe<Scalars['String']['input']>;
  deletedByNotIn: InputMaybe<Array<Scalars['String']['input']>>;
  deletedByNotNil: InputMaybe<Scalars['Boolean']['input']>;
  /** organization edge predicates */
  hasOrganization: InputMaybe<Scalars['Boolean']['input']>;
  hasOrganizationWith: InputMaybe<Array<OrganizationWhereInput>>;
  /** id field predicates */
  id: InputMaybe<Scalars['ID']['input']>;
  idContainsFold: InputMaybe<Scalars['ID']['input']>;
  idEqualFold: InputMaybe<Scalars['ID']['input']>;
  idGT: InputMaybe<Scalars['ID']['input']>;
  idGTE: InputMaybe<Scalars['ID']['input']>;
  idIn: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT: InputMaybe<Scalars['ID']['input']>;
  idLTE: InputMaybe<Scalars['ID']['input']>;
  idNEQ: InputMaybe<Scalars['ID']['input']>;
  idNotIn: InputMaybe<Array<Scalars['ID']['input']>>;
  not: InputMaybe<OrganizationSettingWhereInput>;
  or: InputMaybe<Array<OrganizationSettingWhereInput>>;
  /** sso_cert field predicates */
  ssoCert: InputMaybe<Scalars['String']['input']>;
  ssoCertContains: InputMaybe<Scalars['String']['input']>;
  ssoCertContainsFold: InputMaybe<Scalars['String']['input']>;
  ssoCertEqualFold: InputMaybe<Scalars['String']['input']>;
  ssoCertGT: InputMaybe<Scalars['String']['input']>;
  ssoCertGTE: InputMaybe<Scalars['String']['input']>;
  ssoCertHasPrefix: InputMaybe<Scalars['String']['input']>;
  ssoCertHasSuffix: InputMaybe<Scalars['String']['input']>;
  ssoCertIn: InputMaybe<Array<Scalars['String']['input']>>;
  ssoCertIsNil: InputMaybe<Scalars['Boolean']['input']>;
  ssoCertLT: InputMaybe<Scalars['String']['input']>;
  ssoCertLTE: InputMaybe<Scalars['String']['input']>;
  ssoCertNEQ: InputMaybe<Scalars['String']['input']>;
  ssoCertNotIn: InputMaybe<Array<Scalars['String']['input']>>;
  ssoCertNotNil: InputMaybe<Scalars['Boolean']['input']>;
  /** sso_entrypoint field predicates */
  ssoEntrypoint: InputMaybe<Scalars['String']['input']>;
  ssoEntrypointContains: InputMaybe<Scalars['String']['input']>;
  ssoEntrypointContainsFold: InputMaybe<Scalars['String']['input']>;
  ssoEntrypointEqualFold: InputMaybe<Scalars['String']['input']>;
  ssoEntrypointGT: InputMaybe<Scalars['String']['input']>;
  ssoEntrypointGTE: InputMaybe<Scalars['String']['input']>;
  ssoEntrypointHasPrefix: InputMaybe<Scalars['String']['input']>;
  ssoEntrypointHasSuffix: InputMaybe<Scalars['String']['input']>;
  ssoEntrypointIn: InputMaybe<Array<Scalars['String']['input']>>;
  ssoEntrypointIsNil: InputMaybe<Scalars['Boolean']['input']>;
  ssoEntrypointLT: InputMaybe<Scalars['String']['input']>;
  ssoEntrypointLTE: InputMaybe<Scalars['String']['input']>;
  ssoEntrypointNEQ: InputMaybe<Scalars['String']['input']>;
  ssoEntrypointNotIn: InputMaybe<Array<Scalars['String']['input']>>;
  ssoEntrypointNotNil: InputMaybe<Scalars['Boolean']['input']>;
  /** sso_issuer field predicates */
  ssoIssuer: InputMaybe<Scalars['String']['input']>;
  ssoIssuerContains: InputMaybe<Scalars['String']['input']>;
  ssoIssuerContainsFold: InputMaybe<Scalars['String']['input']>;
  ssoIssuerEqualFold: InputMaybe<Scalars['String']['input']>;
  ssoIssuerGT: InputMaybe<Scalars['String']['input']>;
  ssoIssuerGTE: InputMaybe<Scalars['String']['input']>;
  ssoIssuerHasPrefix: InputMaybe<Scalars['String']['input']>;
  ssoIssuerHasSuffix: InputMaybe<Scalars['String']['input']>;
  ssoIssuerIn: InputMaybe<Array<Scalars['String']['input']>>;
  ssoIssuerIsNil: InputMaybe<Scalars['Boolean']['input']>;
  ssoIssuerLT: InputMaybe<Scalars['String']['input']>;
  ssoIssuerLTE: InputMaybe<Scalars['String']['input']>;
  ssoIssuerNEQ: InputMaybe<Scalars['String']['input']>;
  ssoIssuerNotIn: InputMaybe<Array<Scalars['String']['input']>>;
  ssoIssuerNotNil: InputMaybe<Scalars['Boolean']['input']>;
  /** tax_identifier field predicates */
  taxIdentifier: InputMaybe<Scalars['String']['input']>;
  taxIdentifierContains: InputMaybe<Scalars['String']['input']>;
  taxIdentifierContainsFold: InputMaybe<Scalars['String']['input']>;
  taxIdentifierEqualFold: InputMaybe<Scalars['String']['input']>;
  taxIdentifierGT: InputMaybe<Scalars['String']['input']>;
  taxIdentifierGTE: InputMaybe<Scalars['String']['input']>;
  taxIdentifierHasPrefix: InputMaybe<Scalars['String']['input']>;
  taxIdentifierHasSuffix: InputMaybe<Scalars['String']['input']>;
  taxIdentifierIn: InputMaybe<Array<Scalars['String']['input']>>;
  taxIdentifierIsNil: InputMaybe<Scalars['Boolean']['input']>;
  taxIdentifierLT: InputMaybe<Scalars['String']['input']>;
  taxIdentifierLTE: InputMaybe<Scalars['String']['input']>;
  taxIdentifierNEQ: InputMaybe<Scalars['String']['input']>;
  taxIdentifierNotIn: InputMaybe<Array<Scalars['String']['input']>>;
  taxIdentifierNotNil: InputMaybe<Scalars['Boolean']['input']>;
  /** updated_at field predicates */
  updatedAt: InputMaybe<Scalars['Time']['input']>;
  updatedAtGT: InputMaybe<Scalars['Time']['input']>;
  updatedAtGTE: InputMaybe<Scalars['Time']['input']>;
  updatedAtIn: InputMaybe<Array<Scalars['Time']['input']>>;
  updatedAtLT: InputMaybe<Scalars['Time']['input']>;
  updatedAtLTE: InputMaybe<Scalars['Time']['input']>;
  updatedAtNEQ: InputMaybe<Scalars['Time']['input']>;
  updatedAtNotIn: InputMaybe<Array<Scalars['Time']['input']>>;
  /** updated_by field predicates */
  updatedBy: InputMaybe<Scalars['String']['input']>;
  updatedByContains: InputMaybe<Scalars['String']['input']>;
  updatedByContainsFold: InputMaybe<Scalars['String']['input']>;
  updatedByEqualFold: InputMaybe<Scalars['String']['input']>;
  updatedByGT: InputMaybe<Scalars['String']['input']>;
  updatedByGTE: InputMaybe<Scalars['String']['input']>;
  updatedByHasPrefix: InputMaybe<Scalars['String']['input']>;
  updatedByHasSuffix: InputMaybe<Scalars['String']['input']>;
  updatedByIn: InputMaybe<Array<Scalars['String']['input']>>;
  updatedByIsNil: InputMaybe<Scalars['Boolean']['input']>;
  updatedByLT: InputMaybe<Scalars['String']['input']>;
  updatedByLTE: InputMaybe<Scalars['String']['input']>;
  updatedByNEQ: InputMaybe<Scalars['String']['input']>;
  updatedByNotIn: InputMaybe<Array<Scalars['String']['input']>>;
  updatedByNotNil: InputMaybe<Scalars['Boolean']['input']>;
}

/**
 * OrganizationWhereInput is used for filtering Organization objects.
 * Input was generated by ent.
 */
export interface OrganizationWhereInput {
  and: InputMaybe<Array<OrganizationWhereInput>>;
  /** created_at field predicates */
  createdAt: InputMaybe<Scalars['Time']['input']>;
  createdAtGT: InputMaybe<Scalars['Time']['input']>;
  createdAtGTE: InputMaybe<Scalars['Time']['input']>;
  createdAtIn: InputMaybe<Array<Scalars['Time']['input']>>;
  createdAtLT: InputMaybe<Scalars['Time']['input']>;
  createdAtLTE: InputMaybe<Scalars['Time']['input']>;
  createdAtNEQ: InputMaybe<Scalars['Time']['input']>;
  createdAtNotIn: InputMaybe<Array<Scalars['Time']['input']>>;
  /** created_by field predicates */
  createdBy: InputMaybe<Scalars['String']['input']>;
  createdByContains: InputMaybe<Scalars['String']['input']>;
  createdByContainsFold: InputMaybe<Scalars['String']['input']>;
  createdByEqualFold: InputMaybe<Scalars['String']['input']>;
  createdByGT: InputMaybe<Scalars['String']['input']>;
  createdByGTE: InputMaybe<Scalars['String']['input']>;
  createdByHasPrefix: InputMaybe<Scalars['String']['input']>;
  createdByHasSuffix: InputMaybe<Scalars['String']['input']>;
  createdByIn: InputMaybe<Array<Scalars['String']['input']>>;
  createdByIsNil: InputMaybe<Scalars['Boolean']['input']>;
  createdByLT: InputMaybe<Scalars['String']['input']>;
  createdByLTE: InputMaybe<Scalars['String']['input']>;
  createdByNEQ: InputMaybe<Scalars['String']['input']>;
  createdByNotIn: InputMaybe<Array<Scalars['String']['input']>>;
  createdByNotNil: InputMaybe<Scalars['Boolean']['input']>;
  /** deleted_at field predicates */
  deletedAt: InputMaybe<Scalars['Time']['input']>;
  deletedAtGT: InputMaybe<Scalars['Time']['input']>;
  deletedAtGTE: InputMaybe<Scalars['Time']['input']>;
  deletedAtIn: InputMaybe<Array<Scalars['Time']['input']>>;
  deletedAtIsNil: InputMaybe<Scalars['Boolean']['input']>;
  deletedAtLT: InputMaybe<Scalars['Time']['input']>;
  deletedAtLTE: InputMaybe<Scalars['Time']['input']>;
  deletedAtNEQ: InputMaybe<Scalars['Time']['input']>;
  deletedAtNotIn: InputMaybe<Array<Scalars['Time']['input']>>;
  deletedAtNotNil: InputMaybe<Scalars['Boolean']['input']>;
  /** deleted_by field predicates */
  deletedBy: InputMaybe<Scalars['String']['input']>;
  deletedByContains: InputMaybe<Scalars['String']['input']>;
  deletedByContainsFold: InputMaybe<Scalars['String']['input']>;
  deletedByEqualFold: InputMaybe<Scalars['String']['input']>;
  deletedByGT: InputMaybe<Scalars['String']['input']>;
  deletedByGTE: InputMaybe<Scalars['String']['input']>;
  deletedByHasPrefix: InputMaybe<Scalars['String']['input']>;
  deletedByHasSuffix: InputMaybe<Scalars['String']['input']>;
  deletedByIn: InputMaybe<Array<Scalars['String']['input']>>;
  deletedByIsNil: InputMaybe<Scalars['Boolean']['input']>;
  deletedByLT: InputMaybe<Scalars['String']['input']>;
  deletedByLTE: InputMaybe<Scalars['String']['input']>;
  deletedByNEQ: InputMaybe<Scalars['String']['input']>;
  deletedByNotIn: InputMaybe<Array<Scalars['String']['input']>>;
  deletedByNotNil: InputMaybe<Scalars['Boolean']['input']>;
  /** display_name field predicates */
  displayName: InputMaybe<Scalars['String']['input']>;
  displayNameContains: InputMaybe<Scalars['String']['input']>;
  displayNameContainsFold: InputMaybe<Scalars['String']['input']>;
  displayNameEqualFold: InputMaybe<Scalars['String']['input']>;
  displayNameGT: InputMaybe<Scalars['String']['input']>;
  displayNameGTE: InputMaybe<Scalars['String']['input']>;
  displayNameHasPrefix: InputMaybe<Scalars['String']['input']>;
  displayNameHasSuffix: InputMaybe<Scalars['String']['input']>;
  displayNameIn: InputMaybe<Array<Scalars['String']['input']>>;
  displayNameLT: InputMaybe<Scalars['String']['input']>;
  displayNameLTE: InputMaybe<Scalars['String']['input']>;
  displayNameNEQ: InputMaybe<Scalars['String']['input']>;
  displayNameNotIn: InputMaybe<Array<Scalars['String']['input']>>;
  /** children edge predicates */
  hasChildren: InputMaybe<Scalars['Boolean']['input']>;
  hasChildrenWith: InputMaybe<Array<OrganizationWhereInput>>;
  /** entitlements edge predicates */
  hasEntitlements: InputMaybe<Scalars['Boolean']['input']>;
  hasEntitlementsWith: InputMaybe<Array<EntitlementWhereInput>>;
  /** groups edge predicates */
  hasGroups: InputMaybe<Scalars['Boolean']['input']>;
  hasGroupsWith: InputMaybe<Array<GroupWhereInput>>;
  /** integrations edge predicates */
  hasIntegrations: InputMaybe<Scalars['Boolean']['input']>;
  hasIntegrationsWith: InputMaybe<Array<IntegrationWhereInput>>;
  /** members edge predicates */
  hasMembers: InputMaybe<Scalars['Boolean']['input']>;
  hasMembersWith: InputMaybe<Array<OrgMembershipWhereInput>>;
  /** oauthprovider edge predicates */
  hasOauthprovider: InputMaybe<Scalars['Boolean']['input']>;
  hasOauthproviderWith: InputMaybe<Array<OauthProviderWhereInput>>;
  /** parent edge predicates */
  hasParent: InputMaybe<Scalars['Boolean']['input']>;
  hasParentWith: InputMaybe<Array<OrganizationWhereInput>>;
  /** setting edge predicates */
  hasSetting: InputMaybe<Scalars['Boolean']['input']>;
  hasSettingWith: InputMaybe<Array<OrganizationSettingWhereInput>>;
  /** users edge predicates */
  hasUsers: InputMaybe<Scalars['Boolean']['input']>;
  hasUsersWith: InputMaybe<Array<UserWhereInput>>;
  /** id field predicates */
  id: InputMaybe<Scalars['ID']['input']>;
  idContainsFold: InputMaybe<Scalars['ID']['input']>;
  idEqualFold: InputMaybe<Scalars['ID']['input']>;
  idGT: InputMaybe<Scalars['ID']['input']>;
  idGTE: InputMaybe<Scalars['ID']['input']>;
  idIn: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT: InputMaybe<Scalars['ID']['input']>;
  idLTE: InputMaybe<Scalars['ID']['input']>;
  idNEQ: InputMaybe<Scalars['ID']['input']>;
  idNotIn: InputMaybe<Array<Scalars['ID']['input']>>;
  not: InputMaybe<OrganizationWhereInput>;
  or: InputMaybe<Array<OrganizationWhereInput>>;
  /** parent_organization_id field predicates */
  parentOrganizationID: InputMaybe<Scalars['ID']['input']>;
  parentOrganizationIDContains: InputMaybe<Scalars['ID']['input']>;
  parentOrganizationIDContainsFold: InputMaybe<Scalars['ID']['input']>;
  parentOrganizationIDEqualFold: InputMaybe<Scalars['ID']['input']>;
  parentOrganizationIDGT: InputMaybe<Scalars['ID']['input']>;
  parentOrganizationIDGTE: InputMaybe<Scalars['ID']['input']>;
  parentOrganizationIDHasPrefix: InputMaybe<Scalars['ID']['input']>;
  parentOrganizationIDHasSuffix: InputMaybe<Scalars['ID']['input']>;
  parentOrganizationIDIn: InputMaybe<Array<Scalars['ID']['input']>>;
  parentOrganizationIDIsNil: InputMaybe<Scalars['Boolean']['input']>;
  parentOrganizationIDLT: InputMaybe<Scalars['ID']['input']>;
  parentOrganizationIDLTE: InputMaybe<Scalars['ID']['input']>;
  parentOrganizationIDNEQ: InputMaybe<Scalars['ID']['input']>;
  parentOrganizationIDNotIn: InputMaybe<Array<Scalars['ID']['input']>>;
  parentOrganizationIDNotNil: InputMaybe<Scalars['Boolean']['input']>;
  /** personal_org field predicates */
  personalOrg: InputMaybe<Scalars['Boolean']['input']>;
  personalOrgNEQ: InputMaybe<Scalars['Boolean']['input']>;
  /** updated_at field predicates */
  updatedAt: InputMaybe<Scalars['Time']['input']>;
  updatedAtGT: InputMaybe<Scalars['Time']['input']>;
  updatedAtGTE: InputMaybe<Scalars['Time']['input']>;
  updatedAtIn: InputMaybe<Array<Scalars['Time']['input']>>;
  updatedAtLT: InputMaybe<Scalars['Time']['input']>;
  updatedAtLTE: InputMaybe<Scalars['Time']['input']>;
  updatedAtNEQ: InputMaybe<Scalars['Time']['input']>;
  updatedAtNotIn: InputMaybe<Array<Scalars['Time']['input']>>;
  /** updated_by field predicates */
  updatedBy: InputMaybe<Scalars['String']['input']>;
  updatedByContains: InputMaybe<Scalars['String']['input']>;
  updatedByContainsFold: InputMaybe<Scalars['String']['input']>;
  updatedByEqualFold: InputMaybe<Scalars['String']['input']>;
  updatedByGT: InputMaybe<Scalars['String']['input']>;
  updatedByGTE: InputMaybe<Scalars['String']['input']>;
  updatedByHasPrefix: InputMaybe<Scalars['String']['input']>;
  updatedByHasSuffix: InputMaybe<Scalars['String']['input']>;
  updatedByIn: InputMaybe<Array<Scalars['String']['input']>>;
  updatedByIsNil: InputMaybe<Scalars['Boolean']['input']>;
  updatedByLT: InputMaybe<Scalars['String']['input']>;
  updatedByLTE: InputMaybe<Scalars['String']['input']>;
  updatedByNEQ: InputMaybe<Scalars['String']['input']>;
  updatedByNotIn: InputMaybe<Array<Scalars['String']['input']>>;
  updatedByNotNil: InputMaybe<Scalars['Boolean']['input']>;
}

/**
 * PersonalAccessTokenWhereInput is used for filtering PersonalAccessToken objects.
 * Input was generated by ent.
 */
export interface PersonalAccessTokenWhereInput {
  and: InputMaybe<Array<PersonalAccessTokenWhereInput>>;
  /** created_at field predicates */
  createdAt: InputMaybe<Scalars['Time']['input']>;
  createdAtGT: InputMaybe<Scalars['Time']['input']>;
  createdAtGTE: InputMaybe<Scalars['Time']['input']>;
  createdAtIn: InputMaybe<Array<Scalars['Time']['input']>>;
  createdAtLT: InputMaybe<Scalars['Time']['input']>;
  createdAtLTE: InputMaybe<Scalars['Time']['input']>;
  createdAtNEQ: InputMaybe<Scalars['Time']['input']>;
  createdAtNotIn: InputMaybe<Array<Scalars['Time']['input']>>;
  /** created_by field predicates */
  createdBy: InputMaybe<Scalars['String']['input']>;
  createdByContains: InputMaybe<Scalars['String']['input']>;
  createdByContainsFold: InputMaybe<Scalars['String']['input']>;
  createdByEqualFold: InputMaybe<Scalars['String']['input']>;
  createdByGT: InputMaybe<Scalars['String']['input']>;
  createdByGTE: InputMaybe<Scalars['String']['input']>;
  createdByHasPrefix: InputMaybe<Scalars['String']['input']>;
  createdByHasSuffix: InputMaybe<Scalars['String']['input']>;
  createdByIn: InputMaybe<Array<Scalars['String']['input']>>;
  createdByIsNil: InputMaybe<Scalars['Boolean']['input']>;
  createdByLT: InputMaybe<Scalars['String']['input']>;
  createdByLTE: InputMaybe<Scalars['String']['input']>;
  createdByNEQ: InputMaybe<Scalars['String']['input']>;
  createdByNotIn: InputMaybe<Array<Scalars['String']['input']>>;
  createdByNotNil: InputMaybe<Scalars['Boolean']['input']>;
  /** deleted_at field predicates */
  deletedAt: InputMaybe<Scalars['Time']['input']>;
  deletedAtGT: InputMaybe<Scalars['Time']['input']>;
  deletedAtGTE: InputMaybe<Scalars['Time']['input']>;
  deletedAtIn: InputMaybe<Array<Scalars['Time']['input']>>;
  deletedAtIsNil: InputMaybe<Scalars['Boolean']['input']>;
  deletedAtLT: InputMaybe<Scalars['Time']['input']>;
  deletedAtLTE: InputMaybe<Scalars['Time']['input']>;
  deletedAtNEQ: InputMaybe<Scalars['Time']['input']>;
  deletedAtNotIn: InputMaybe<Array<Scalars['Time']['input']>>;
  deletedAtNotNil: InputMaybe<Scalars['Boolean']['input']>;
  /** deleted_by field predicates */
  deletedBy: InputMaybe<Scalars['String']['input']>;
  deletedByContains: InputMaybe<Scalars['String']['input']>;
  deletedByContainsFold: InputMaybe<Scalars['String']['input']>;
  deletedByEqualFold: InputMaybe<Scalars['String']['input']>;
  deletedByGT: InputMaybe<Scalars['String']['input']>;
  deletedByGTE: InputMaybe<Scalars['String']['input']>;
  deletedByHasPrefix: InputMaybe<Scalars['String']['input']>;
  deletedByHasSuffix: InputMaybe<Scalars['String']['input']>;
  deletedByIn: InputMaybe<Array<Scalars['String']['input']>>;
  deletedByIsNil: InputMaybe<Scalars['Boolean']['input']>;
  deletedByLT: InputMaybe<Scalars['String']['input']>;
  deletedByLTE: InputMaybe<Scalars['String']['input']>;
  deletedByNEQ: InputMaybe<Scalars['String']['input']>;
  deletedByNotIn: InputMaybe<Array<Scalars['String']['input']>>;
  deletedByNotNil: InputMaybe<Scalars['Boolean']['input']>;
  /** expires_at field predicates */
  expiresAt: InputMaybe<Scalars['Time']['input']>;
  expiresAtGT: InputMaybe<Scalars['Time']['input']>;
  expiresAtGTE: InputMaybe<Scalars['Time']['input']>;
  expiresAtIn: InputMaybe<Array<Scalars['Time']['input']>>;
  expiresAtLT: InputMaybe<Scalars['Time']['input']>;
  expiresAtLTE: InputMaybe<Scalars['Time']['input']>;
  expiresAtNEQ: InputMaybe<Scalars['Time']['input']>;
  expiresAtNotIn: InputMaybe<Array<Scalars['Time']['input']>>;
  /** owner edge predicates */
  hasOwner: InputMaybe<Scalars['Boolean']['input']>;
  hasOwnerWith: InputMaybe<Array<UserWhereInput>>;
  /** id field predicates */
  id: InputMaybe<Scalars['ID']['input']>;
  idContainsFold: InputMaybe<Scalars['ID']['input']>;
  idEqualFold: InputMaybe<Scalars['ID']['input']>;
  idGT: InputMaybe<Scalars['ID']['input']>;
  idGTE: InputMaybe<Scalars['ID']['input']>;
  idIn: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT: InputMaybe<Scalars['ID']['input']>;
  idLTE: InputMaybe<Scalars['ID']['input']>;
  idNEQ: InputMaybe<Scalars['ID']['input']>;
  idNotIn: InputMaybe<Array<Scalars['ID']['input']>>;
  /** last_used_at field predicates */
  lastUsedAt: InputMaybe<Scalars['Time']['input']>;
  lastUsedAtGT: InputMaybe<Scalars['Time']['input']>;
  lastUsedAtGTE: InputMaybe<Scalars['Time']['input']>;
  lastUsedAtIn: InputMaybe<Array<Scalars['Time']['input']>>;
  lastUsedAtIsNil: InputMaybe<Scalars['Boolean']['input']>;
  lastUsedAtLT: InputMaybe<Scalars['Time']['input']>;
  lastUsedAtLTE: InputMaybe<Scalars['Time']['input']>;
  lastUsedAtNEQ: InputMaybe<Scalars['Time']['input']>;
  lastUsedAtNotIn: InputMaybe<Array<Scalars['Time']['input']>>;
  lastUsedAtNotNil: InputMaybe<Scalars['Boolean']['input']>;
  /** name field predicates */
  name: InputMaybe<Scalars['String']['input']>;
  nameContains: InputMaybe<Scalars['String']['input']>;
  nameContainsFold: InputMaybe<Scalars['String']['input']>;
  nameEqualFold: InputMaybe<Scalars['String']['input']>;
  nameGT: InputMaybe<Scalars['String']['input']>;
  nameGTE: InputMaybe<Scalars['String']['input']>;
  nameHasPrefix: InputMaybe<Scalars['String']['input']>;
  nameHasSuffix: InputMaybe<Scalars['String']['input']>;
  nameIn: InputMaybe<Array<Scalars['String']['input']>>;
  nameLT: InputMaybe<Scalars['String']['input']>;
  nameLTE: InputMaybe<Scalars['String']['input']>;
  nameNEQ: InputMaybe<Scalars['String']['input']>;
  nameNotIn: InputMaybe<Array<Scalars['String']['input']>>;
  not: InputMaybe<PersonalAccessTokenWhereInput>;
  or: InputMaybe<Array<PersonalAccessTokenWhereInput>>;
  /** updated_at field predicates */
  updatedAt: InputMaybe<Scalars['Time']['input']>;
  updatedAtGT: InputMaybe<Scalars['Time']['input']>;
  updatedAtGTE: InputMaybe<Scalars['Time']['input']>;
  updatedAtIn: InputMaybe<Array<Scalars['Time']['input']>>;
  updatedAtLT: InputMaybe<Scalars['Time']['input']>;
  updatedAtLTE: InputMaybe<Scalars['Time']['input']>;
  updatedAtNEQ: InputMaybe<Scalars['Time']['input']>;
  updatedAtNotIn: InputMaybe<Array<Scalars['Time']['input']>>;
  /** updated_by field predicates */
  updatedBy: InputMaybe<Scalars['String']['input']>;
  updatedByContains: InputMaybe<Scalars['String']['input']>;
  updatedByContainsFold: InputMaybe<Scalars['String']['input']>;
  updatedByEqualFold: InputMaybe<Scalars['String']['input']>;
  updatedByGT: InputMaybe<Scalars['String']['input']>;
  updatedByGTE: InputMaybe<Scalars['String']['input']>;
  updatedByHasPrefix: InputMaybe<Scalars['String']['input']>;
  updatedByHasSuffix: InputMaybe<Scalars['String']['input']>;
  updatedByIn: InputMaybe<Array<Scalars['String']['input']>>;
  updatedByIsNil: InputMaybe<Scalars['Boolean']['input']>;
  updatedByLT: InputMaybe<Scalars['String']['input']>;
  updatedByLTE: InputMaybe<Scalars['String']['input']>;
  updatedByNEQ: InputMaybe<Scalars['String']['input']>;
  updatedByNotIn: InputMaybe<Array<Scalars['String']['input']>>;
  updatedByNotNil: InputMaybe<Scalars['Boolean']['input']>;
}

/**
 * SessionWhereInput is used for filtering Session objects.
 * Input was generated by ent.
 */
export interface SessionWhereInput {
  and: InputMaybe<Array<SessionWhereInput>>;
  /** created_at field predicates */
  createdAt: InputMaybe<Scalars['Time']['input']>;
  createdAtGT: InputMaybe<Scalars['Time']['input']>;
  createdAtGTE: InputMaybe<Scalars['Time']['input']>;
  createdAtIn: InputMaybe<Array<Scalars['Time']['input']>>;
  createdAtLT: InputMaybe<Scalars['Time']['input']>;
  createdAtLTE: InputMaybe<Scalars['Time']['input']>;
  createdAtNEQ: InputMaybe<Scalars['Time']['input']>;
  createdAtNotIn: InputMaybe<Array<Scalars['Time']['input']>>;
  /** created_by field predicates */
  createdBy: InputMaybe<Scalars['String']['input']>;
  createdByContains: InputMaybe<Scalars['String']['input']>;
  createdByContainsFold: InputMaybe<Scalars['String']['input']>;
  createdByEqualFold: InputMaybe<Scalars['String']['input']>;
  createdByGT: InputMaybe<Scalars['String']['input']>;
  createdByGTE: InputMaybe<Scalars['String']['input']>;
  createdByHasPrefix: InputMaybe<Scalars['String']['input']>;
  createdByHasSuffix: InputMaybe<Scalars['String']['input']>;
  createdByIn: InputMaybe<Array<Scalars['String']['input']>>;
  createdByIsNil: InputMaybe<Scalars['Boolean']['input']>;
  createdByLT: InputMaybe<Scalars['String']['input']>;
  createdByLTE: InputMaybe<Scalars['String']['input']>;
  createdByNEQ: InputMaybe<Scalars['String']['input']>;
  createdByNotIn: InputMaybe<Array<Scalars['String']['input']>>;
  createdByNotNil: InputMaybe<Scalars['Boolean']['input']>;
  /** expires_at field predicates */
  expiresAt: InputMaybe<Scalars['Time']['input']>;
  expiresAtGT: InputMaybe<Scalars['Time']['input']>;
  expiresAtGTE: InputMaybe<Scalars['Time']['input']>;
  expiresAtIn: InputMaybe<Array<Scalars['Time']['input']>>;
  expiresAtLT: InputMaybe<Scalars['Time']['input']>;
  expiresAtLTE: InputMaybe<Scalars['Time']['input']>;
  expiresAtNEQ: InputMaybe<Scalars['Time']['input']>;
  expiresAtNotIn: InputMaybe<Array<Scalars['Time']['input']>>;
  /** owner edge predicates */
  hasOwner: InputMaybe<Scalars['Boolean']['input']>;
  hasOwnerWith: InputMaybe<Array<UserWhereInput>>;
  /** id field predicates */
  id: InputMaybe<Scalars['ID']['input']>;
  idContainsFold: InputMaybe<Scalars['ID']['input']>;
  idEqualFold: InputMaybe<Scalars['ID']['input']>;
  idGT: InputMaybe<Scalars['ID']['input']>;
  idGTE: InputMaybe<Scalars['ID']['input']>;
  idIn: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT: InputMaybe<Scalars['ID']['input']>;
  idLTE: InputMaybe<Scalars['ID']['input']>;
  idNEQ: InputMaybe<Scalars['ID']['input']>;
  idNotIn: InputMaybe<Array<Scalars['ID']['input']>>;
  /** issued_at field predicates */
  issuedAt: InputMaybe<Scalars['Time']['input']>;
  issuedAtGT: InputMaybe<Scalars['Time']['input']>;
  issuedAtGTE: InputMaybe<Scalars['Time']['input']>;
  issuedAtIn: InputMaybe<Array<Scalars['Time']['input']>>;
  issuedAtLT: InputMaybe<Scalars['Time']['input']>;
  issuedAtLTE: InputMaybe<Scalars['Time']['input']>;
  issuedAtNEQ: InputMaybe<Scalars['Time']['input']>;
  issuedAtNotIn: InputMaybe<Array<Scalars['Time']['input']>>;
  not: InputMaybe<SessionWhereInput>;
  or: InputMaybe<Array<SessionWhereInput>>;
  /** organization_id field predicates */
  organizationID: InputMaybe<Scalars['String']['input']>;
  organizationIDContains: InputMaybe<Scalars['String']['input']>;
  organizationIDContainsFold: InputMaybe<Scalars['String']['input']>;
  organizationIDEqualFold: InputMaybe<Scalars['String']['input']>;
  organizationIDGT: InputMaybe<Scalars['String']['input']>;
  organizationIDGTE: InputMaybe<Scalars['String']['input']>;
  organizationIDHasPrefix: InputMaybe<Scalars['String']['input']>;
  organizationIDHasSuffix: InputMaybe<Scalars['String']['input']>;
  organizationIDIn: InputMaybe<Array<Scalars['String']['input']>>;
  organizationIDLT: InputMaybe<Scalars['String']['input']>;
  organizationIDLTE: InputMaybe<Scalars['String']['input']>;
  organizationIDNEQ: InputMaybe<Scalars['String']['input']>;
  organizationIDNotIn: InputMaybe<Array<Scalars['String']['input']>>;
  /** session_token field predicates */
  sessionToken: InputMaybe<Scalars['String']['input']>;
  sessionTokenContains: InputMaybe<Scalars['String']['input']>;
  sessionTokenContainsFold: InputMaybe<Scalars['String']['input']>;
  sessionTokenEqualFold: InputMaybe<Scalars['String']['input']>;
  sessionTokenGT: InputMaybe<Scalars['String']['input']>;
  sessionTokenGTE: InputMaybe<Scalars['String']['input']>;
  sessionTokenHasPrefix: InputMaybe<Scalars['String']['input']>;
  sessionTokenHasSuffix: InputMaybe<Scalars['String']['input']>;
  sessionTokenIn: InputMaybe<Array<Scalars['String']['input']>>;
  sessionTokenLT: InputMaybe<Scalars['String']['input']>;
  sessionTokenLTE: InputMaybe<Scalars['String']['input']>;
  sessionTokenNEQ: InputMaybe<Scalars['String']['input']>;
  sessionTokenNotIn: InputMaybe<Array<Scalars['String']['input']>>;
  /** updated_at field predicates */
  updatedAt: InputMaybe<Scalars['Time']['input']>;
  updatedAtGT: InputMaybe<Scalars['Time']['input']>;
  updatedAtGTE: InputMaybe<Scalars['Time']['input']>;
  updatedAtIn: InputMaybe<Array<Scalars['Time']['input']>>;
  updatedAtLT: InputMaybe<Scalars['Time']['input']>;
  updatedAtLTE: InputMaybe<Scalars['Time']['input']>;
  updatedAtNEQ: InputMaybe<Scalars['Time']['input']>;
  updatedAtNotIn: InputMaybe<Array<Scalars['Time']['input']>>;
  /** updated_by field predicates */
  updatedBy: InputMaybe<Scalars['String']['input']>;
  updatedByContains: InputMaybe<Scalars['String']['input']>;
  updatedByContainsFold: InputMaybe<Scalars['String']['input']>;
  updatedByEqualFold: InputMaybe<Scalars['String']['input']>;
  updatedByGT: InputMaybe<Scalars['String']['input']>;
  updatedByGTE: InputMaybe<Scalars['String']['input']>;
  updatedByHasPrefix: InputMaybe<Scalars['String']['input']>;
  updatedByHasSuffix: InputMaybe<Scalars['String']['input']>;
  updatedByIn: InputMaybe<Array<Scalars['String']['input']>>;
  updatedByIsNil: InputMaybe<Scalars['Boolean']['input']>;
  updatedByLT: InputMaybe<Scalars['String']['input']>;
  updatedByLTE: InputMaybe<Scalars['String']['input']>;
  updatedByNEQ: InputMaybe<Scalars['String']['input']>;
  updatedByNotIn: InputMaybe<Array<Scalars['String']['input']>>;
  updatedByNotNil: InputMaybe<Scalars['Boolean']['input']>;
}

/**
 * UpdateEntitlementInput is used for update Entitlement object.
 * Input was generated by ent.
 */
export interface UpdateEntitlementInput {
  /** whether or not the customer has cancelled their entitlement - usually used in conjunction with expires and expires at */
  cancelled: InputMaybe<Scalars['Boolean']['input']>;
  clearExpiresAt: InputMaybe<Scalars['Boolean']['input']>;
  clearExternalCustomerID: InputMaybe<Scalars['Boolean']['input']>;
  clearExternalSubscriptionID: InputMaybe<Scalars['Boolean']['input']>;
  clearUpdatedBy: InputMaybe<Scalars['Boolean']['input']>;
  /** whether or not the customers entitlement expires - expires_at will show the time */
  expires: InputMaybe<Scalars['Boolean']['input']>;
  /** the time at which a customer's entitlement will expire, e.g. they've cancelled but paid through the end of the month */
  expiresAt: InputMaybe<Scalars['Time']['input']>;
  /** used to store references to external systems, e.g. Stripe */
  externalCustomerID: InputMaybe<Scalars['String']['input']>;
  /** used to store references to external systems, e.g. Stripe */
  externalSubscriptionID: InputMaybe<Scalars['String']['input']>;
  ownerID: InputMaybe<Scalars['ID']['input']>;
  tier: InputMaybe<EntitlementTier>;
  updatedAt: InputMaybe<Scalars['Time']['input']>;
  updatedBy: InputMaybe<Scalars['String']['input']>;
}

/**
 * UpdateGroupInput is used for update Group object.
 * Input was generated by ent.
 */
export interface UpdateGroupInput {
  addUserIDs: InputMaybe<Array<Scalars['ID']['input']>>;
  clearDescription: InputMaybe<Scalars['Boolean']['input']>;
  clearGravatarLogoURL: InputMaybe<Scalars['Boolean']['input']>;
  clearLogoURL: InputMaybe<Scalars['Boolean']['input']>;
  clearUpdatedBy: InputMaybe<Scalars['Boolean']['input']>;
  clearUsers: InputMaybe<Scalars['Boolean']['input']>;
  /** the groups description */
  description: InputMaybe<Scalars['String']['input']>;
  /** The group's displayed 'friendly' name */
  displayName: InputMaybe<Scalars['String']['input']>;
  /** the URL to an auto generated gravatar image for the group */
  gravatarLogoURL: InputMaybe<Scalars['String']['input']>;
  /** the URL to an image uploaded by the customer for the groups avatar image */
  logoURL: InputMaybe<Scalars['String']['input']>;
  /** the name of the group - must be unique within the organization */
  name: InputMaybe<Scalars['String']['input']>;
  ownerID: InputMaybe<Scalars['ID']['input']>;
  removeUserIDs: InputMaybe<Array<Scalars['ID']['input']>>;
  settingID: InputMaybe<Scalars['ID']['input']>;
  updatedAt: InputMaybe<Scalars['Time']['input']>;
  updatedBy: InputMaybe<Scalars['String']['input']>;
}

/**
 * UpdateGroupMembershipInput is used for update GroupMembership object.
 * Input was generated by ent.
 */
export interface UpdateGroupMembershipInput {
  clearUpdatedBy: InputMaybe<Scalars['Boolean']['input']>;
  role: InputMaybe<GroupMembershipRole>;
  updatedAt: InputMaybe<Scalars['Time']['input']>;
  updatedBy: InputMaybe<Scalars['String']['input']>;
}

/**
 * UpdateGroupSettingInput is used for update GroupSetting object.
 * Input was generated by ent.
 */
export interface UpdateGroupSettingInput {
  appendTags: InputMaybe<Array<Scalars['String']['input']>>;
  clearGroup: InputMaybe<Scalars['Boolean']['input']>;
  clearUpdatedBy: InputMaybe<Scalars['Boolean']['input']>;
  groupID: InputMaybe<Scalars['ID']['input']>;
  /** the policy governing ability to freely join a group, whether it requires an invitation, application, or either */
  joinPolicy: InputMaybe<GroupSettingJoinPolicy>;
  syncToGithub: InputMaybe<Scalars['Boolean']['input']>;
  syncToSlack: InputMaybe<Scalars['Boolean']['input']>;
  /** tags associated with the object */
  tags: InputMaybe<Array<Scalars['String']['input']>>;
  updatedAt: InputMaybe<Scalars['Time']['input']>;
  updatedBy: InputMaybe<Scalars['String']['input']>;
  /** whether the group is visible to it's members / owners only or if it's searchable by anyone within the organization */
  visibility: InputMaybe<GroupSettingVisibility>;
}

/**
 * UpdateIntegrationInput is used for update Integration object.
 * Input was generated by ent.
 */
export interface UpdateIntegrationInput {
  clearDescription: InputMaybe<Scalars['Boolean']['input']>;
  clearKind: InputMaybe<Scalars['Boolean']['input']>;
  clearOwner: InputMaybe<Scalars['Boolean']['input']>;
  clearUpdatedBy: InputMaybe<Scalars['Boolean']['input']>;
  /** a description of the integration */
  description: InputMaybe<Scalars['String']['input']>;
  kind: InputMaybe<Scalars['String']['input']>;
  /** the name of the integration - must be unique within the organization */
  name: InputMaybe<Scalars['String']['input']>;
  ownerID: InputMaybe<Scalars['ID']['input']>;
  updatedAt: InputMaybe<Scalars['Time']['input']>;
  updatedBy: InputMaybe<Scalars['String']['input']>;
}

/**
 * UpdateOauthProviderInput is used for update OauthProvider object.
 * Input was generated by ent.
 */
export interface UpdateOauthProviderInput {
  /** the auth style, 0: auto detect 1: third party log in 2: log in with username and password */
  authStyle: InputMaybe<Scalars['Int']['input']>;
  /** the auth url of the provider */
  authURL: InputMaybe<Scalars['String']['input']>;
  clearOwner: InputMaybe<Scalars['Boolean']['input']>;
  clearUpdatedBy: InputMaybe<Scalars['Boolean']['input']>;
  /** the client id for the oauth provider */
  clientID: InputMaybe<Scalars['String']['input']>;
  /** the client secret */
  clientSecret: InputMaybe<Scalars['String']['input']>;
  /** the URL to request user information by token */
  infoURL: InputMaybe<Scalars['String']['input']>;
  /** the oauth provider's name */
  name: InputMaybe<Scalars['String']['input']>;
  ownerID: InputMaybe<Scalars['ID']['input']>;
  /** the redirect url */
  redirectURL: InputMaybe<Scalars['String']['input']>;
  /** the scopes */
  scopes: InputMaybe<Scalars['String']['input']>;
  /** the token url of the provider */
  tokenURL: InputMaybe<Scalars['String']['input']>;
  updatedAt: InputMaybe<Scalars['Time']['input']>;
  updatedBy: InputMaybe<Scalars['String']['input']>;
}

/**
 * UpdateOhAuthTooTokenInput is used for update OhAuthTooToken object.
 * Input was generated by ent.
 */
export interface UpdateOhAuthTooTokenInput {
  appendClaimsGroups: InputMaybe<Array<Scalars['String']['input']>>;
  appendConnectorData: InputMaybe<Array<Scalars['String']['input']>>;
  appendScopes: InputMaybe<Array<Scalars['String']['input']>>;
  claimsEmail: InputMaybe<Scalars['String']['input']>;
  claimsEmailVerified: InputMaybe<Scalars['Boolean']['input']>;
  claimsGroups: InputMaybe<Array<Scalars['String']['input']>>;
  claimsPreferredUsername: InputMaybe<Scalars['String']['input']>;
  claimsUserID: InputMaybe<Scalars['String']['input']>;
  claimsUsername: InputMaybe<Scalars['String']['input']>;
  clearClaimsGroups: InputMaybe<Scalars['Boolean']['input']>;
  clearConnectorData: InputMaybe<Scalars['Boolean']['input']>;
  clearScopes: InputMaybe<Scalars['Boolean']['input']>;
  clientID: InputMaybe<Scalars['String']['input']>;
  connectorData: InputMaybe<Array<Scalars['String']['input']>>;
  connectorID: InputMaybe<Scalars['String']['input']>;
  lastUsed: InputMaybe<Scalars['Time']['input']>;
  nonce: InputMaybe<Scalars['String']['input']>;
  scopes: InputMaybe<Array<Scalars['String']['input']>>;
}

/**
 * UpdateOrgMembershipInput is used for update OrgMembership object.
 * Input was generated by ent.
 */
export interface UpdateOrgMembershipInput {
  clearUpdatedBy: InputMaybe<Scalars['Boolean']['input']>;
  role: InputMaybe<OrgMembershipRole>;
  updatedAt: InputMaybe<Scalars['Time']['input']>;
  updatedBy: InputMaybe<Scalars['String']['input']>;
}

/**
 * UpdateOrganizationInput is used for update Organization object.
 * Input was generated by ent.
 */
export interface UpdateOrganizationInput {
  addEntitlementIDs: InputMaybe<Array<Scalars['ID']['input']>>;
  addGroupIDs: InputMaybe<Array<Scalars['ID']['input']>>;
  addIntegrationIDs: InputMaybe<Array<Scalars['ID']['input']>>;
  addOauthproviderIDs: InputMaybe<Array<Scalars['ID']['input']>>;
  addUserIDs: InputMaybe<Array<Scalars['ID']['input']>>;
  clearDescription: InputMaybe<Scalars['Boolean']['input']>;
  clearEntitlements: InputMaybe<Scalars['Boolean']['input']>;
  clearGroups: InputMaybe<Scalars['Boolean']['input']>;
  clearIntegrations: InputMaybe<Scalars['Boolean']['input']>;
  clearOauthprovider: InputMaybe<Scalars['Boolean']['input']>;
  clearSetting: InputMaybe<Scalars['Boolean']['input']>;
  clearUpdatedBy: InputMaybe<Scalars['Boolean']['input']>;
  clearUsers: InputMaybe<Scalars['Boolean']['input']>;
  /** An optional description of the organization */
  description: InputMaybe<Scalars['String']['input']>;
  /** The organization's displayed 'friendly' name */
  displayName: InputMaybe<Scalars['String']['input']>;
  /** the name of the organization */
  name: InputMaybe<Scalars['String']['input']>;
  removeEntitlementIDs: InputMaybe<Array<Scalars['ID']['input']>>;
  removeGroupIDs: InputMaybe<Array<Scalars['ID']['input']>>;
  removeIntegrationIDs: InputMaybe<Array<Scalars['ID']['input']>>;
  removeOauthproviderIDs: InputMaybe<Array<Scalars['ID']['input']>>;
  removeUserIDs: InputMaybe<Array<Scalars['ID']['input']>>;
  settingID: InputMaybe<Scalars['ID']['input']>;
  updatedAt: InputMaybe<Scalars['Time']['input']>;
  updatedBy: InputMaybe<Scalars['String']['input']>;
}

/**
 * UpdateOrganizationSettingInput is used for update OrganizationSetting object.
 * Input was generated by ent.
 */
export interface UpdateOrganizationSettingInput {
  appendDomains: InputMaybe<Array<Scalars['String']['input']>>;
  appendTags: InputMaybe<Array<Scalars['String']['input']>>;
  billingAddress: InputMaybe<Scalars['String']['input']>;
  /** Name of the person to contact for billing */
  billingContact: InputMaybe<Scalars['String']['input']>;
  billingEmail: InputMaybe<Scalars['String']['input']>;
  billingPhone: InputMaybe<Scalars['String']['input']>;
  clearBillingAddress: InputMaybe<Scalars['Boolean']['input']>;
  clearBillingContact: InputMaybe<Scalars['Boolean']['input']>;
  clearBillingEmail: InputMaybe<Scalars['Boolean']['input']>;
  clearBillingPhone: InputMaybe<Scalars['Boolean']['input']>;
  clearDomains: InputMaybe<Scalars['Boolean']['input']>;
  clearOrganization: InputMaybe<Scalars['Boolean']['input']>;
  clearSSOCert: InputMaybe<Scalars['Boolean']['input']>;
  clearSSOEntrypoint: InputMaybe<Scalars['Boolean']['input']>;
  clearSSOIssuer: InputMaybe<Scalars['Boolean']['input']>;
  clearTags: InputMaybe<Scalars['Boolean']['input']>;
  clearTaxIdentifier: InputMaybe<Scalars['Boolean']['input']>;
  clearUpdatedBy: InputMaybe<Scalars['Boolean']['input']>;
  /** domains associated with the organization */
  domains: InputMaybe<Array<Scalars['String']['input']>>;
  organizationID: InputMaybe<Scalars['ID']['input']>;
  ssoCert: InputMaybe<Scalars['String']['input']>;
  ssoEntrypoint: InputMaybe<Scalars['String']['input']>;
  ssoIssuer: InputMaybe<Scalars['String']['input']>;
  /** tags associated with the object */
  tags: InputMaybe<Array<Scalars['String']['input']>>;
  /** Usually government-issued tax ID or business ID such as ABN in Australia */
  taxIdentifier: InputMaybe<Scalars['String']['input']>;
  updatedAt: InputMaybe<Scalars['Time']['input']>;
  updatedBy: InputMaybe<Scalars['String']['input']>;
}

/**
 * UpdatePersonalAccessTokenInput is used for update PersonalAccessToken object.
 * Input was generated by ent.
 */
export interface UpdatePersonalAccessTokenInput {
  /** what abilites the token should have */
  abilities: InputMaybe<Array<Scalars['String']['input']>>;
  appendAbilities: InputMaybe<Array<Scalars['String']['input']>>;
  clearAbilities: InputMaybe<Scalars['Boolean']['input']>;
  clearDescription: InputMaybe<Scalars['Boolean']['input']>;
  clearLastUsedAt: InputMaybe<Scalars['Boolean']['input']>;
  clearUpdatedBy: InputMaybe<Scalars['Boolean']['input']>;
  /** a description of the token's purpose */
  description: InputMaybe<Scalars['String']['input']>;
  /** when the token expires */
  expiresAt: InputMaybe<Scalars['Time']['input']>;
  lastUsedAt: InputMaybe<Scalars['Time']['input']>;
  /** the name associated with the token */
  name: InputMaybe<Scalars['String']['input']>;
  ownerID: InputMaybe<Scalars['ID']['input']>;
  updatedAt: InputMaybe<Scalars['Time']['input']>;
  updatedBy: InputMaybe<Scalars['String']['input']>;
}

/**
 * UpdateSessionInput is used for update Session object.
 * Input was generated by ent.
 */
export interface UpdateSessionInput {
  clearUpdatedBy: InputMaybe<Scalars['Boolean']['input']>;
  expiresAt: InputMaybe<Scalars['Time']['input']>;
  issuedAt: InputMaybe<Scalars['Time']['input']>;
  /** organization ID of the organization the user is accessing */
  organizationID: InputMaybe<Scalars['String']['input']>;
  ownerID: InputMaybe<Scalars['ID']['input']>;
  updatedAt: InputMaybe<Scalars['Time']['input']>;
  updatedBy: InputMaybe<Scalars['String']['input']>;
}

/**
 * UpdateUserInput is used for update User object.
 * Input was generated by ent.
 */
export interface UpdateUserInput {
  addEmailVerificationTokenIDs: InputMaybe<Array<Scalars['ID']['input']>>;
  addGroupIDs: InputMaybe<Array<Scalars['ID']['input']>>;
  addOrganizationIDs: InputMaybe<Array<Scalars['ID']['input']>>;
  addPasswordResetTokenIDs: InputMaybe<Array<Scalars['ID']['input']>>;
  addPersonalAccessTokenIDs: InputMaybe<Array<Scalars['ID']['input']>>;
  addSessionIDs: InputMaybe<Array<Scalars['ID']['input']>>;
  /** The user's local avatar file */
  avatarLocalFile: InputMaybe<Scalars['String']['input']>;
  /** URL of the user's remote avatar */
  avatarRemoteURL: InputMaybe<Scalars['String']['input']>;
  /** The time the user's (local) avatar was last updated */
  avatarUpdatedAt: InputMaybe<Scalars['Time']['input']>;
  clearAvatarLocalFile: InputMaybe<Scalars['Boolean']['input']>;
  clearAvatarRemoteURL: InputMaybe<Scalars['Boolean']['input']>;
  clearAvatarUpdatedAt: InputMaybe<Scalars['Boolean']['input']>;
  clearEmailVerificationTokens: InputMaybe<Scalars['Boolean']['input']>;
  clearGroups: InputMaybe<Scalars['Boolean']['input']>;
  clearLastSeen: InputMaybe<Scalars['Boolean']['input']>;
  clearOrganizations: InputMaybe<Scalars['Boolean']['input']>;
  clearPassword: InputMaybe<Scalars['Boolean']['input']>;
  clearPasswordResetTokens: InputMaybe<Scalars['Boolean']['input']>;
  clearPersonalAccessTokens: InputMaybe<Scalars['Boolean']['input']>;
  clearSessions: InputMaybe<Scalars['Boolean']['input']>;
  clearSub: InputMaybe<Scalars['Boolean']['input']>;
  clearUpdatedBy: InputMaybe<Scalars['Boolean']['input']>;
  /** The user's displayed 'friendly' name */
  displayName: InputMaybe<Scalars['String']['input']>;
  email: InputMaybe<Scalars['String']['input']>;
  firstName: InputMaybe<Scalars['String']['input']>;
  lastName: InputMaybe<Scalars['String']['input']>;
  /** the time the user was last seen */
  lastSeen: InputMaybe<Scalars['Time']['input']>;
  /** whether the user uses oauth for login or not */
  oauth: InputMaybe<Scalars['Boolean']['input']>;
  /** user password hash */
  password: InputMaybe<Scalars['String']['input']>;
  removeEmailVerificationTokenIDs: InputMaybe<Array<Scalars['ID']['input']>>;
  removeGroupIDs: InputMaybe<Array<Scalars['ID']['input']>>;
  removeOrganizationIDs: InputMaybe<Array<Scalars['ID']['input']>>;
  removePasswordResetTokenIDs: InputMaybe<Array<Scalars['ID']['input']>>;
  removePersonalAccessTokenIDs: InputMaybe<Array<Scalars['ID']['input']>>;
  removeSessionIDs: InputMaybe<Array<Scalars['ID']['input']>>;
  settingID: InputMaybe<Scalars['ID']['input']>;
  /** the Subject of the user JWT */
  sub: InputMaybe<Scalars['String']['input']>;
  updatedAt: InputMaybe<Scalars['Time']['input']>;
  updatedBy: InputMaybe<Scalars['String']['input']>;
}

/**
 * UpdateUserSettingInput is used for update UserSetting object.
 * Input was generated by ent.
 */
export interface UpdateUserSettingInput {
  appendPermissions: InputMaybe<Array<Scalars['String']['input']>>;
  appendTags: InputMaybe<Array<Scalars['String']['input']>>;
  clearRecoveryCode: InputMaybe<Scalars['Boolean']['input']>;
  clearSilencedAt: InputMaybe<Scalars['Boolean']['input']>;
  clearSuspendedAt: InputMaybe<Scalars['Boolean']['input']>;
  clearUpdatedBy: InputMaybe<Scalars['Boolean']['input']>;
  clearUser: InputMaybe<Scalars['Boolean']['input']>;
  emailConfirmed: InputMaybe<Scalars['Boolean']['input']>;
  /** user account is locked if unconfirmed or explicitly locked */
  locked: InputMaybe<Scalars['Boolean']['input']>;
  permissions: InputMaybe<Array<Scalars['String']['input']>>;
  /** local user password recovery code generated during account creation - does not exist for oauth'd users */
  recoveryCode: InputMaybe<Scalars['String']['input']>;
  role: InputMaybe<UserSettingRole>;
  /** The time notifications regarding the user were silenced */
  silencedAt: InputMaybe<Scalars['Time']['input']>;
  status: InputMaybe<UserSettingStatus>;
  /** The time the user was suspended */
  suspendedAt: InputMaybe<Scalars['Time']['input']>;
  /** tags associated with the object */
  tags: InputMaybe<Array<Scalars['String']['input']>>;
  updatedAt: InputMaybe<Scalars['Time']['input']>;
  updatedBy: InputMaybe<Scalars['String']['input']>;
  userID: InputMaybe<Scalars['ID']['input']>;
}

/** Ordering options for User connections */
export interface UserOrder {
  /** The ordering direction. */
  direction: OrderDirection;
  /** The field by which to order Users. */
  field: UserOrderField;
}

/** Properties by which User connections can be ordered. */
export enum UserOrderField {
  display_name = 'display_name',
  first_name = 'first_name',
  last_name = 'last_name'
}

/** UserSettingRole is enum for the field role */
export enum UserSettingRole {
  ADMIN = 'ADMIN',
  OWNER = 'OWNER',
  USER = 'USER'
}

/** UserSettingStatus is enum for the field status */
export enum UserSettingStatus {
  ACTIVE = 'ACTIVE',
  DEACTIVATED = 'DEACTIVATED',
  INACTIVE = 'INACTIVE',
  SUSPENDED = 'SUSPENDED'
}

/**
 * UserSettingWhereInput is used for filtering UserSetting objects.
 * Input was generated by ent.
 */
export interface UserSettingWhereInput {
  and: InputMaybe<Array<UserSettingWhereInput>>;
  /** created_at field predicates */
  createdAt: InputMaybe<Scalars['Time']['input']>;
  createdAtGT: InputMaybe<Scalars['Time']['input']>;
  createdAtGTE: InputMaybe<Scalars['Time']['input']>;
  createdAtIn: InputMaybe<Array<Scalars['Time']['input']>>;
  createdAtLT: InputMaybe<Scalars['Time']['input']>;
  createdAtLTE: InputMaybe<Scalars['Time']['input']>;
  createdAtNEQ: InputMaybe<Scalars['Time']['input']>;
  createdAtNotIn: InputMaybe<Array<Scalars['Time']['input']>>;
  /** created_by field predicates */
  createdBy: InputMaybe<Scalars['String']['input']>;
  createdByContains: InputMaybe<Scalars['String']['input']>;
  createdByContainsFold: InputMaybe<Scalars['String']['input']>;
  createdByEqualFold: InputMaybe<Scalars['String']['input']>;
  createdByGT: InputMaybe<Scalars['String']['input']>;
  createdByGTE: InputMaybe<Scalars['String']['input']>;
  createdByHasPrefix: InputMaybe<Scalars['String']['input']>;
  createdByHasSuffix: InputMaybe<Scalars['String']['input']>;
  createdByIn: InputMaybe<Array<Scalars['String']['input']>>;
  createdByIsNil: InputMaybe<Scalars['Boolean']['input']>;
  createdByLT: InputMaybe<Scalars['String']['input']>;
  createdByLTE: InputMaybe<Scalars['String']['input']>;
  createdByNEQ: InputMaybe<Scalars['String']['input']>;
  createdByNotIn: InputMaybe<Array<Scalars['String']['input']>>;
  createdByNotNil: InputMaybe<Scalars['Boolean']['input']>;
  /** deleted_at field predicates */
  deletedAt: InputMaybe<Scalars['Time']['input']>;
  deletedAtGT: InputMaybe<Scalars['Time']['input']>;
  deletedAtGTE: InputMaybe<Scalars['Time']['input']>;
  deletedAtIn: InputMaybe<Array<Scalars['Time']['input']>>;
  deletedAtIsNil: InputMaybe<Scalars['Boolean']['input']>;
  deletedAtLT: InputMaybe<Scalars['Time']['input']>;
  deletedAtLTE: InputMaybe<Scalars['Time']['input']>;
  deletedAtNEQ: InputMaybe<Scalars['Time']['input']>;
  deletedAtNotIn: InputMaybe<Array<Scalars['Time']['input']>>;
  deletedAtNotNil: InputMaybe<Scalars['Boolean']['input']>;
  /** deleted_by field predicates */
  deletedBy: InputMaybe<Scalars['String']['input']>;
  deletedByContains: InputMaybe<Scalars['String']['input']>;
  deletedByContainsFold: InputMaybe<Scalars['String']['input']>;
  deletedByEqualFold: InputMaybe<Scalars['String']['input']>;
  deletedByGT: InputMaybe<Scalars['String']['input']>;
  deletedByGTE: InputMaybe<Scalars['String']['input']>;
  deletedByHasPrefix: InputMaybe<Scalars['String']['input']>;
  deletedByHasSuffix: InputMaybe<Scalars['String']['input']>;
  deletedByIn: InputMaybe<Array<Scalars['String']['input']>>;
  deletedByIsNil: InputMaybe<Scalars['Boolean']['input']>;
  deletedByLT: InputMaybe<Scalars['String']['input']>;
  deletedByLTE: InputMaybe<Scalars['String']['input']>;
  deletedByNEQ: InputMaybe<Scalars['String']['input']>;
  deletedByNotIn: InputMaybe<Array<Scalars['String']['input']>>;
  deletedByNotNil: InputMaybe<Scalars['Boolean']['input']>;
  /** email_confirmed field predicates */
  emailConfirmed: InputMaybe<Scalars['Boolean']['input']>;
  emailConfirmedNEQ: InputMaybe<Scalars['Boolean']['input']>;
  /** user edge predicates */
  hasUser: InputMaybe<Scalars['Boolean']['input']>;
  hasUserWith: InputMaybe<Array<UserWhereInput>>;
  /** id field predicates */
  id: InputMaybe<Scalars['ID']['input']>;
  idContainsFold: InputMaybe<Scalars['ID']['input']>;
  idEqualFold: InputMaybe<Scalars['ID']['input']>;
  idGT: InputMaybe<Scalars['ID']['input']>;
  idGTE: InputMaybe<Scalars['ID']['input']>;
  idIn: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT: InputMaybe<Scalars['ID']['input']>;
  idLTE: InputMaybe<Scalars['ID']['input']>;
  idNEQ: InputMaybe<Scalars['ID']['input']>;
  idNotIn: InputMaybe<Array<Scalars['ID']['input']>>;
  /** locked field predicates */
  locked: InputMaybe<Scalars['Boolean']['input']>;
  lockedNEQ: InputMaybe<Scalars['Boolean']['input']>;
  not: InputMaybe<UserSettingWhereInput>;
  or: InputMaybe<Array<UserSettingWhereInput>>;
  /** role field predicates */
  role: InputMaybe<UserSettingRole>;
  roleIn: InputMaybe<Array<UserSettingRole>>;
  roleNEQ: InputMaybe<UserSettingRole>;
  roleNotIn: InputMaybe<Array<UserSettingRole>>;
  /** silenced_at field predicates */
  silencedAt: InputMaybe<Scalars['Time']['input']>;
  silencedAtGT: InputMaybe<Scalars['Time']['input']>;
  silencedAtGTE: InputMaybe<Scalars['Time']['input']>;
  silencedAtIn: InputMaybe<Array<Scalars['Time']['input']>>;
  silencedAtIsNil: InputMaybe<Scalars['Boolean']['input']>;
  silencedAtLT: InputMaybe<Scalars['Time']['input']>;
  silencedAtLTE: InputMaybe<Scalars['Time']['input']>;
  silencedAtNEQ: InputMaybe<Scalars['Time']['input']>;
  silencedAtNotIn: InputMaybe<Array<Scalars['Time']['input']>>;
  silencedAtNotNil: InputMaybe<Scalars['Boolean']['input']>;
  /** status field predicates */
  status: InputMaybe<UserSettingStatus>;
  statusIn: InputMaybe<Array<UserSettingStatus>>;
  statusNEQ: InputMaybe<UserSettingStatus>;
  statusNotIn: InputMaybe<Array<UserSettingStatus>>;
  /** suspended_at field predicates */
  suspendedAt: InputMaybe<Scalars['Time']['input']>;
  suspendedAtGT: InputMaybe<Scalars['Time']['input']>;
  suspendedAtGTE: InputMaybe<Scalars['Time']['input']>;
  suspendedAtIn: InputMaybe<Array<Scalars['Time']['input']>>;
  suspendedAtIsNil: InputMaybe<Scalars['Boolean']['input']>;
  suspendedAtLT: InputMaybe<Scalars['Time']['input']>;
  suspendedAtLTE: InputMaybe<Scalars['Time']['input']>;
  suspendedAtNEQ: InputMaybe<Scalars['Time']['input']>;
  suspendedAtNotIn: InputMaybe<Array<Scalars['Time']['input']>>;
  suspendedAtNotNil: InputMaybe<Scalars['Boolean']['input']>;
  /** updated_at field predicates */
  updatedAt: InputMaybe<Scalars['Time']['input']>;
  updatedAtGT: InputMaybe<Scalars['Time']['input']>;
  updatedAtGTE: InputMaybe<Scalars['Time']['input']>;
  updatedAtIn: InputMaybe<Array<Scalars['Time']['input']>>;
  updatedAtLT: InputMaybe<Scalars['Time']['input']>;
  updatedAtLTE: InputMaybe<Scalars['Time']['input']>;
  updatedAtNEQ: InputMaybe<Scalars['Time']['input']>;
  updatedAtNotIn: InputMaybe<Array<Scalars['Time']['input']>>;
  /** updated_by field predicates */
  updatedBy: InputMaybe<Scalars['String']['input']>;
  updatedByContains: InputMaybe<Scalars['String']['input']>;
  updatedByContainsFold: InputMaybe<Scalars['String']['input']>;
  updatedByEqualFold: InputMaybe<Scalars['String']['input']>;
  updatedByGT: InputMaybe<Scalars['String']['input']>;
  updatedByGTE: InputMaybe<Scalars['String']['input']>;
  updatedByHasPrefix: InputMaybe<Scalars['String']['input']>;
  updatedByHasSuffix: InputMaybe<Scalars['String']['input']>;
  updatedByIn: InputMaybe<Array<Scalars['String']['input']>>;
  updatedByIsNil: InputMaybe<Scalars['Boolean']['input']>;
  updatedByLT: InputMaybe<Scalars['String']['input']>;
  updatedByLTE: InputMaybe<Scalars['String']['input']>;
  updatedByNEQ: InputMaybe<Scalars['String']['input']>;
  updatedByNotIn: InputMaybe<Array<Scalars['String']['input']>>;
  updatedByNotNil: InputMaybe<Scalars['Boolean']['input']>;
}

/**
 * UserWhereInput is used for filtering User objects.
 * Input was generated by ent.
 */
export interface UserWhereInput {
  and: InputMaybe<Array<UserWhereInput>>;
  /** avatar_local_file field predicates */
  avatarLocalFile: InputMaybe<Scalars['String']['input']>;
  avatarLocalFileContains: InputMaybe<Scalars['String']['input']>;
  avatarLocalFileContainsFold: InputMaybe<Scalars['String']['input']>;
  avatarLocalFileEqualFold: InputMaybe<Scalars['String']['input']>;
  avatarLocalFileGT: InputMaybe<Scalars['String']['input']>;
  avatarLocalFileGTE: InputMaybe<Scalars['String']['input']>;
  avatarLocalFileHasPrefix: InputMaybe<Scalars['String']['input']>;
  avatarLocalFileHasSuffix: InputMaybe<Scalars['String']['input']>;
  avatarLocalFileIn: InputMaybe<Array<Scalars['String']['input']>>;
  avatarLocalFileIsNil: InputMaybe<Scalars['Boolean']['input']>;
  avatarLocalFileLT: InputMaybe<Scalars['String']['input']>;
  avatarLocalFileLTE: InputMaybe<Scalars['String']['input']>;
  avatarLocalFileNEQ: InputMaybe<Scalars['String']['input']>;
  avatarLocalFileNotIn: InputMaybe<Array<Scalars['String']['input']>>;
  avatarLocalFileNotNil: InputMaybe<Scalars['Boolean']['input']>;
  /** avatar_remote_url field predicates */
  avatarRemoteURL: InputMaybe<Scalars['String']['input']>;
  avatarRemoteURLContains: InputMaybe<Scalars['String']['input']>;
  avatarRemoteURLContainsFold: InputMaybe<Scalars['String']['input']>;
  avatarRemoteURLEqualFold: InputMaybe<Scalars['String']['input']>;
  avatarRemoteURLGT: InputMaybe<Scalars['String']['input']>;
  avatarRemoteURLGTE: InputMaybe<Scalars['String']['input']>;
  avatarRemoteURLHasPrefix: InputMaybe<Scalars['String']['input']>;
  avatarRemoteURLHasSuffix: InputMaybe<Scalars['String']['input']>;
  avatarRemoteURLIn: InputMaybe<Array<Scalars['String']['input']>>;
  avatarRemoteURLIsNil: InputMaybe<Scalars['Boolean']['input']>;
  avatarRemoteURLLT: InputMaybe<Scalars['String']['input']>;
  avatarRemoteURLLTE: InputMaybe<Scalars['String']['input']>;
  avatarRemoteURLNEQ: InputMaybe<Scalars['String']['input']>;
  avatarRemoteURLNotIn: InputMaybe<Array<Scalars['String']['input']>>;
  avatarRemoteURLNotNil: InputMaybe<Scalars['Boolean']['input']>;
  /** avatar_updated_at field predicates */
  avatarUpdatedAt: InputMaybe<Scalars['Time']['input']>;
  avatarUpdatedAtGT: InputMaybe<Scalars['Time']['input']>;
  avatarUpdatedAtGTE: InputMaybe<Scalars['Time']['input']>;
  avatarUpdatedAtIn: InputMaybe<Array<Scalars['Time']['input']>>;
  avatarUpdatedAtIsNil: InputMaybe<Scalars['Boolean']['input']>;
  avatarUpdatedAtLT: InputMaybe<Scalars['Time']['input']>;
  avatarUpdatedAtLTE: InputMaybe<Scalars['Time']['input']>;
  avatarUpdatedAtNEQ: InputMaybe<Scalars['Time']['input']>;
  avatarUpdatedAtNotIn: InputMaybe<Array<Scalars['Time']['input']>>;
  avatarUpdatedAtNotNil: InputMaybe<Scalars['Boolean']['input']>;
  /** created_at field predicates */
  createdAt: InputMaybe<Scalars['Time']['input']>;
  createdAtGT: InputMaybe<Scalars['Time']['input']>;
  createdAtGTE: InputMaybe<Scalars['Time']['input']>;
  createdAtIn: InputMaybe<Array<Scalars['Time']['input']>>;
  createdAtLT: InputMaybe<Scalars['Time']['input']>;
  createdAtLTE: InputMaybe<Scalars['Time']['input']>;
  createdAtNEQ: InputMaybe<Scalars['Time']['input']>;
  createdAtNotIn: InputMaybe<Array<Scalars['Time']['input']>>;
  /** created_by field predicates */
  createdBy: InputMaybe<Scalars['String']['input']>;
  createdByContains: InputMaybe<Scalars['String']['input']>;
  createdByContainsFold: InputMaybe<Scalars['String']['input']>;
  createdByEqualFold: InputMaybe<Scalars['String']['input']>;
  createdByGT: InputMaybe<Scalars['String']['input']>;
  createdByGTE: InputMaybe<Scalars['String']['input']>;
  createdByHasPrefix: InputMaybe<Scalars['String']['input']>;
  createdByHasSuffix: InputMaybe<Scalars['String']['input']>;
  createdByIn: InputMaybe<Array<Scalars['String']['input']>>;
  createdByIsNil: InputMaybe<Scalars['Boolean']['input']>;
  createdByLT: InputMaybe<Scalars['String']['input']>;
  createdByLTE: InputMaybe<Scalars['String']['input']>;
  createdByNEQ: InputMaybe<Scalars['String']['input']>;
  createdByNotIn: InputMaybe<Array<Scalars['String']['input']>>;
  createdByNotNil: InputMaybe<Scalars['Boolean']['input']>;
  /** deleted_at field predicates */
  deletedAt: InputMaybe<Scalars['Time']['input']>;
  deletedAtGT: InputMaybe<Scalars['Time']['input']>;
  deletedAtGTE: InputMaybe<Scalars['Time']['input']>;
  deletedAtIn: InputMaybe<Array<Scalars['Time']['input']>>;
  deletedAtIsNil: InputMaybe<Scalars['Boolean']['input']>;
  deletedAtLT: InputMaybe<Scalars['Time']['input']>;
  deletedAtLTE: InputMaybe<Scalars['Time']['input']>;
  deletedAtNEQ: InputMaybe<Scalars['Time']['input']>;
  deletedAtNotIn: InputMaybe<Array<Scalars['Time']['input']>>;
  deletedAtNotNil: InputMaybe<Scalars['Boolean']['input']>;
  /** deleted_by field predicates */
  deletedBy: InputMaybe<Scalars['String']['input']>;
  deletedByContains: InputMaybe<Scalars['String']['input']>;
  deletedByContainsFold: InputMaybe<Scalars['String']['input']>;
  deletedByEqualFold: InputMaybe<Scalars['String']['input']>;
  deletedByGT: InputMaybe<Scalars['String']['input']>;
  deletedByGTE: InputMaybe<Scalars['String']['input']>;
  deletedByHasPrefix: InputMaybe<Scalars['String']['input']>;
  deletedByHasSuffix: InputMaybe<Scalars['String']['input']>;
  deletedByIn: InputMaybe<Array<Scalars['String']['input']>>;
  deletedByIsNil: InputMaybe<Scalars['Boolean']['input']>;
  deletedByLT: InputMaybe<Scalars['String']['input']>;
  deletedByLTE: InputMaybe<Scalars['String']['input']>;
  deletedByNEQ: InputMaybe<Scalars['String']['input']>;
  deletedByNotIn: InputMaybe<Array<Scalars['String']['input']>>;
  deletedByNotNil: InputMaybe<Scalars['Boolean']['input']>;
  /** display_name field predicates */
  displayName: InputMaybe<Scalars['String']['input']>;
  displayNameContains: InputMaybe<Scalars['String']['input']>;
  displayNameContainsFold: InputMaybe<Scalars['String']['input']>;
  displayNameEqualFold: InputMaybe<Scalars['String']['input']>;
  displayNameGT: InputMaybe<Scalars['String']['input']>;
  displayNameGTE: InputMaybe<Scalars['String']['input']>;
  displayNameHasPrefix: InputMaybe<Scalars['String']['input']>;
  displayNameHasSuffix: InputMaybe<Scalars['String']['input']>;
  displayNameIn: InputMaybe<Array<Scalars['String']['input']>>;
  displayNameLT: InputMaybe<Scalars['String']['input']>;
  displayNameLTE: InputMaybe<Scalars['String']['input']>;
  displayNameNEQ: InputMaybe<Scalars['String']['input']>;
  displayNameNotIn: InputMaybe<Array<Scalars['String']['input']>>;
  /** email field predicates */
  email: InputMaybe<Scalars['String']['input']>;
  emailContains: InputMaybe<Scalars['String']['input']>;
  emailContainsFold: InputMaybe<Scalars['String']['input']>;
  emailEqualFold: InputMaybe<Scalars['String']['input']>;
  emailGT: InputMaybe<Scalars['String']['input']>;
  emailGTE: InputMaybe<Scalars['String']['input']>;
  emailHasPrefix: InputMaybe<Scalars['String']['input']>;
  emailHasSuffix: InputMaybe<Scalars['String']['input']>;
  emailIn: InputMaybe<Array<Scalars['String']['input']>>;
  emailLT: InputMaybe<Scalars['String']['input']>;
  emailLTE: InputMaybe<Scalars['String']['input']>;
  emailNEQ: InputMaybe<Scalars['String']['input']>;
  emailNotIn: InputMaybe<Array<Scalars['String']['input']>>;
  /** first_name field predicates */
  firstName: InputMaybe<Scalars['String']['input']>;
  firstNameContains: InputMaybe<Scalars['String']['input']>;
  firstNameContainsFold: InputMaybe<Scalars['String']['input']>;
  firstNameEqualFold: InputMaybe<Scalars['String']['input']>;
  firstNameGT: InputMaybe<Scalars['String']['input']>;
  firstNameGTE: InputMaybe<Scalars['String']['input']>;
  firstNameHasPrefix: InputMaybe<Scalars['String']['input']>;
  firstNameHasSuffix: InputMaybe<Scalars['String']['input']>;
  firstNameIn: InputMaybe<Array<Scalars['String']['input']>>;
  firstNameLT: InputMaybe<Scalars['String']['input']>;
  firstNameLTE: InputMaybe<Scalars['String']['input']>;
  firstNameNEQ: InputMaybe<Scalars['String']['input']>;
  firstNameNotIn: InputMaybe<Array<Scalars['String']['input']>>;
  /** group_memberships edge predicates */
  hasGroupMemberships: InputMaybe<Scalars['Boolean']['input']>;
  hasGroupMembershipsWith: InputMaybe<Array<GroupMembershipWhereInput>>;
  /** groups edge predicates */
  hasGroups: InputMaybe<Scalars['Boolean']['input']>;
  hasGroupsWith: InputMaybe<Array<GroupWhereInput>>;
  /** org_memberships edge predicates */
  hasOrgMemberships: InputMaybe<Scalars['Boolean']['input']>;
  hasOrgMembershipsWith: InputMaybe<Array<OrgMembershipWhereInput>>;
  /** organizations edge predicates */
  hasOrganizations: InputMaybe<Scalars['Boolean']['input']>;
  hasOrganizationsWith: InputMaybe<Array<OrganizationWhereInput>>;
  /** personal_access_tokens edge predicates */
  hasPersonalAccessTokens: InputMaybe<Scalars['Boolean']['input']>;
  hasPersonalAccessTokensWith: InputMaybe<Array<PersonalAccessTokenWhereInput>>;
  /** sessions edge predicates */
  hasSessions: InputMaybe<Scalars['Boolean']['input']>;
  hasSessionsWith: InputMaybe<Array<SessionWhereInput>>;
  /** setting edge predicates */
  hasSetting: InputMaybe<Scalars['Boolean']['input']>;
  hasSettingWith: InputMaybe<Array<UserSettingWhereInput>>;
  /** id field predicates */
  id: InputMaybe<Scalars['ID']['input']>;
  idContainsFold: InputMaybe<Scalars['ID']['input']>;
  idEqualFold: InputMaybe<Scalars['ID']['input']>;
  idGT: InputMaybe<Scalars['ID']['input']>;
  idGTE: InputMaybe<Scalars['ID']['input']>;
  idIn: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT: InputMaybe<Scalars['ID']['input']>;
  idLTE: InputMaybe<Scalars['ID']['input']>;
  idNEQ: InputMaybe<Scalars['ID']['input']>;
  idNotIn: InputMaybe<Array<Scalars['ID']['input']>>;
  /** last_name field predicates */
  lastName: InputMaybe<Scalars['String']['input']>;
  lastNameContains: InputMaybe<Scalars['String']['input']>;
  lastNameContainsFold: InputMaybe<Scalars['String']['input']>;
  lastNameEqualFold: InputMaybe<Scalars['String']['input']>;
  lastNameGT: InputMaybe<Scalars['String']['input']>;
  lastNameGTE: InputMaybe<Scalars['String']['input']>;
  lastNameHasPrefix: InputMaybe<Scalars['String']['input']>;
  lastNameHasSuffix: InputMaybe<Scalars['String']['input']>;
  lastNameIn: InputMaybe<Array<Scalars['String']['input']>>;
  lastNameLT: InputMaybe<Scalars['String']['input']>;
  lastNameLTE: InputMaybe<Scalars['String']['input']>;
  lastNameNEQ: InputMaybe<Scalars['String']['input']>;
  lastNameNotIn: InputMaybe<Array<Scalars['String']['input']>>;
  /** last_seen field predicates */
  lastSeen: InputMaybe<Scalars['Time']['input']>;
  lastSeenGT: InputMaybe<Scalars['Time']['input']>;
  lastSeenGTE: InputMaybe<Scalars['Time']['input']>;
  lastSeenIn: InputMaybe<Array<Scalars['Time']['input']>>;
  lastSeenIsNil: InputMaybe<Scalars['Boolean']['input']>;
  lastSeenLT: InputMaybe<Scalars['Time']['input']>;
  lastSeenLTE: InputMaybe<Scalars['Time']['input']>;
  lastSeenNEQ: InputMaybe<Scalars['Time']['input']>;
  lastSeenNotIn: InputMaybe<Array<Scalars['Time']['input']>>;
  lastSeenNotNil: InputMaybe<Scalars['Boolean']['input']>;
  not: InputMaybe<UserWhereInput>;
  /** oauth field predicates */
  oauth: InputMaybe<Scalars['Boolean']['input']>;
  oauthNEQ: InputMaybe<Scalars['Boolean']['input']>;
  or: InputMaybe<Array<UserWhereInput>>;
  /** sub field predicates */
  sub: InputMaybe<Scalars['String']['input']>;
  subContains: InputMaybe<Scalars['String']['input']>;
  subContainsFold: InputMaybe<Scalars['String']['input']>;
  subEqualFold: InputMaybe<Scalars['String']['input']>;
  subGT: InputMaybe<Scalars['String']['input']>;
  subGTE: InputMaybe<Scalars['String']['input']>;
  subHasPrefix: InputMaybe<Scalars['String']['input']>;
  subHasSuffix: InputMaybe<Scalars['String']['input']>;
  subIn: InputMaybe<Array<Scalars['String']['input']>>;
  subIsNil: InputMaybe<Scalars['Boolean']['input']>;
  subLT: InputMaybe<Scalars['String']['input']>;
  subLTE: InputMaybe<Scalars['String']['input']>;
  subNEQ: InputMaybe<Scalars['String']['input']>;
  subNotIn: InputMaybe<Array<Scalars['String']['input']>>;
  subNotNil: InputMaybe<Scalars['Boolean']['input']>;
  /** updated_at field predicates */
  updatedAt: InputMaybe<Scalars['Time']['input']>;
  updatedAtGT: InputMaybe<Scalars['Time']['input']>;
  updatedAtGTE: InputMaybe<Scalars['Time']['input']>;
  updatedAtIn: InputMaybe<Array<Scalars['Time']['input']>>;
  updatedAtLT: InputMaybe<Scalars['Time']['input']>;
  updatedAtLTE: InputMaybe<Scalars['Time']['input']>;
  updatedAtNEQ: InputMaybe<Scalars['Time']['input']>;
  updatedAtNotIn: InputMaybe<Array<Scalars['Time']['input']>>;
  /** updated_by field predicates */
  updatedBy: InputMaybe<Scalars['String']['input']>;
  updatedByContains: InputMaybe<Scalars['String']['input']>;
  updatedByContainsFold: InputMaybe<Scalars['String']['input']>;
  updatedByEqualFold: InputMaybe<Scalars['String']['input']>;
  updatedByGT: InputMaybe<Scalars['String']['input']>;
  updatedByGTE: InputMaybe<Scalars['String']['input']>;
  updatedByHasPrefix: InputMaybe<Scalars['String']['input']>;
  updatedByHasSuffix: InputMaybe<Scalars['String']['input']>;
  updatedByIn: InputMaybe<Array<Scalars['String']['input']>>;
  updatedByIsNil: InputMaybe<Scalars['Boolean']['input']>;
  updatedByLT: InputMaybe<Scalars['String']['input']>;
  updatedByLTE: InputMaybe<Scalars['String']['input']>;
  updatedByNEQ: InputMaybe<Scalars['String']['input']>;
  updatedByNotIn: InputMaybe<Array<Scalars['String']['input']>>;
  updatedByNotNil: InputMaybe<Scalars['Boolean']['input']>;
}

export type GetAllGroupsQueryVariables = Exact<{ [key: string]: never; }>;


export type GetAllGroupsQuery = { __typename?: 'Query', groups: { __typename?: 'GroupConnection', edges: Array<{ __typename?: 'GroupEdge', node: { __typename?: 'Group', id: string, name: string, description: string | null, displayName: string, logoURL: string | null, setting: { __typename?: 'GroupSetting', visibility: GroupSettingVisibility, joinPolicy: GroupSettingJoinPolicy, syncToSlack: boolean, syncToGithub: boolean, tags: Array<string> } } | null } | null> | null } };

export type GetUserProfileQueryVariables = Exact<{
  userId: Scalars['ID']['input'];
}>;


export type GetUserProfileQuery = { __typename?: 'Query', user: { __typename?: 'User', id: string, firstName: string, lastName: string, displayName: string, email: string, avatarRemoteURL: string | null, setting: { __typename?: 'UserSetting', status: UserSettingStatus, tags: Array<string> } } };



export type ResolverTypeWrapper<T> = Promise<T> | T;


export type ResolverWithResolve<TResult, TParent, TContext, TArgs> = {
  resolve: ResolverFn<TResult, TParent, TContext, TArgs>;
};
export type Resolver<TResult, TParent = {}, TContext = {}, TArgs = {}> = ResolverFn<TResult, TParent, TContext, TArgs> | ResolverWithResolve<TResult, TParent, TContext, TArgs>;

export type ResolverFn<TResult, TParent, TContext, TArgs> = (
  parent: TParent,
  args: TArgs,
  context: TContext,
  info: GraphQLResolveInfo
) => Promise<TResult> | TResult;

export type SubscriptionSubscribeFn<TResult, TParent, TContext, TArgs> = (
  parent: TParent,
  args: TArgs,
  context: TContext,
  info: GraphQLResolveInfo
) => AsyncIterable<TResult> | Promise<AsyncIterable<TResult>>;

export type SubscriptionResolveFn<TResult, TParent, TContext, TArgs> = (
  parent: TParent,
  args: TArgs,
  context: TContext,
  info: GraphQLResolveInfo
) => TResult | Promise<TResult>;

export interface SubscriptionSubscriberObject<TResult, TKey extends string, TParent, TContext, TArgs> {
  subscribe: SubscriptionSubscribeFn<{ [key in TKey]: TResult }, TParent, TContext, TArgs>;
  resolve?: SubscriptionResolveFn<TResult, { [key in TKey]: TResult }, TContext, TArgs>;
}

export interface SubscriptionResolverObject<TResult, TParent, TContext, TArgs> {
  subscribe: SubscriptionSubscribeFn<any, TParent, TContext, TArgs>;
  resolve: SubscriptionResolveFn<TResult, any, TContext, TArgs>;
}

export type SubscriptionObject<TResult, TKey extends string, TParent, TContext, TArgs> =
  | SubscriptionSubscriberObject<TResult, TKey, TParent, TContext, TArgs>
  | SubscriptionResolverObject<TResult, TParent, TContext, TArgs>;

export type SubscriptionResolver<TResult, TKey extends string, TParent = {}, TContext = {}, TArgs = {}> =
  | ((...args: any[]) => SubscriptionObject<TResult, TKey, TParent, TContext, TArgs>)
  | SubscriptionObject<TResult, TKey, TParent, TContext, TArgs>;

export type TypeResolveFn<TTypes, TParent = {}, TContext = {}> = (
  parent: TParent,
  context: TContext,
  info: GraphQLResolveInfo
) => Maybe<TTypes> | Promise<Maybe<TTypes>>;

export type IsTypeOfResolverFn<T = {}, TContext = {}> = (obj: T, context: TContext, info: GraphQLResolveInfo) => boolean | Promise<boolean>;

export type NextResolverFn<T> = () => Promise<T>;

export type DirectiveResolverFn<TResult = {}, TParent = {}, TContext = {}, TArgs = {}> = (
  next: NextResolverFn<TResult>,
  parent: TParent,
  args: TArgs,
  context: TContext,
  info: GraphQLResolveInfo
) => TResult | Promise<TResult>;


/** Mapping of interface types */
export type ResolversInterfaceTypes<RefType extends Record<string, unknown>> = {
  Node: ( Entitlement ) | ( Group ) | ( GroupMembership ) | ( GroupSetting ) | ( Integration ) | ( OauthProvider ) | ( OhAuthTooToken ) | ( OrgMembership ) | ( Organization ) | ( OrganizationSetting ) | ( PersonalAccessToken ) | ( Session ) | ( User ) | ( UserSetting );
};

/** Mapping between all available schema types and the resolvers types */
export type ResolversTypes = {
  Boolean: ResolverTypeWrapper<Scalars['Boolean']['output']>;
  CreateEntitlementInput: CreateEntitlementInput;
  CreateGroupInput: CreateGroupInput;
  CreateGroupMembershipInput: CreateGroupMembershipInput;
  CreateGroupSettingInput: CreateGroupSettingInput;
  CreateIntegrationInput: CreateIntegrationInput;
  CreateOauthProviderInput: CreateOauthProviderInput;
  CreateOhAuthTooTokenInput: CreateOhAuthTooTokenInput;
  CreateOrgMembershipInput: CreateOrgMembershipInput;
  CreateOrganizationInput: CreateOrganizationInput;
  CreateOrganizationSettingInput: CreateOrganizationSettingInput;
  CreatePersonalAccessTokenInput: CreatePersonalAccessTokenInput;
  CreateSessionInput: CreateSessionInput;
  CreateUserInput: CreateUserInput;
  CreateUserSettingInput: CreateUserSettingInput;
  Cursor: ResolverTypeWrapper<Scalars['Cursor']['output']>;
  Entitlement: ResolverTypeWrapper<Entitlement>;
  EntitlementConnection: ResolverTypeWrapper<EntitlementConnection>;
  EntitlementCreatePayload: ResolverTypeWrapper<EntitlementCreatePayload>;
  EntitlementDeletePayload: ResolverTypeWrapper<EntitlementDeletePayload>;
  EntitlementEdge: ResolverTypeWrapper<EntitlementEdge>;
  EntitlementTier: EntitlementTier;
  EntitlementUpdatePayload: ResolverTypeWrapper<EntitlementUpdatePayload>;
  EntitlementWhereInput: EntitlementWhereInput;
  Group: ResolverTypeWrapper<Group>;
  GroupConnection: ResolverTypeWrapper<GroupConnection>;
  GroupCreatePayload: ResolverTypeWrapper<GroupCreatePayload>;
  GroupDeletePayload: ResolverTypeWrapper<GroupDeletePayload>;
  GroupEdge: ResolverTypeWrapper<GroupEdge>;
  GroupMembership: ResolverTypeWrapper<GroupMembership>;
  GroupMembershipConnection: ResolverTypeWrapper<GroupMembershipConnection>;
  GroupMembershipCreatePayload: ResolverTypeWrapper<GroupMembershipCreatePayload>;
  GroupMembershipDeletePayload: ResolverTypeWrapper<GroupMembershipDeletePayload>;
  GroupMembershipEdge: ResolverTypeWrapper<GroupMembershipEdge>;
  GroupMembershipRole: GroupMembershipRole;
  GroupMembershipUpdatePayload: ResolverTypeWrapper<GroupMembershipUpdatePayload>;
  GroupMembershipWhereInput: GroupMembershipWhereInput;
  GroupOrder: GroupOrder;
  GroupOrderField: GroupOrderField;
  GroupSetting: ResolverTypeWrapper<GroupSetting>;
  GroupSettingConnection: ResolverTypeWrapper<GroupSettingConnection>;
  GroupSettingCreatePayload: ResolverTypeWrapper<GroupSettingCreatePayload>;
  GroupSettingDeletePayload: ResolverTypeWrapper<GroupSettingDeletePayload>;
  GroupSettingEdge: ResolverTypeWrapper<GroupSettingEdge>;
  GroupSettingJoinPolicy: GroupSettingJoinPolicy;
  GroupSettingUpdatePayload: ResolverTypeWrapper<GroupSettingUpdatePayload>;
  GroupSettingVisibility: GroupSettingVisibility;
  GroupSettingWhereInput: GroupSettingWhereInput;
  GroupUpdatePayload: ResolverTypeWrapper<GroupUpdatePayload>;
  GroupWhereInput: GroupWhereInput;
  ID: ResolverTypeWrapper<Scalars['ID']['output']>;
  Int: ResolverTypeWrapper<Scalars['Int']['output']>;
  Integration: ResolverTypeWrapper<Integration>;
  IntegrationConnection: ResolverTypeWrapper<IntegrationConnection>;
  IntegrationCreatePayload: ResolverTypeWrapper<IntegrationCreatePayload>;
  IntegrationDeletePayload: ResolverTypeWrapper<IntegrationDeletePayload>;
  IntegrationEdge: ResolverTypeWrapper<IntegrationEdge>;
  IntegrationOrder: IntegrationOrder;
  IntegrationOrderField: IntegrationOrderField;
  IntegrationUpdatePayload: ResolverTypeWrapper<IntegrationUpdatePayload>;
  IntegrationWhereInput: IntegrationWhereInput;
  JSON: ResolverTypeWrapper<Scalars['JSON']['output']>;
  Mutation: ResolverTypeWrapper<{}>;
  Node: ResolverTypeWrapper<ResolversInterfaceTypes<ResolversTypes>['Node']>;
  OauthProvider: ResolverTypeWrapper<OauthProvider>;
  OauthProviderConnection: ResolverTypeWrapper<OauthProviderConnection>;
  OauthProviderCreatePayload: ResolverTypeWrapper<OauthProviderCreatePayload>;
  OauthProviderDeletePayload: ResolverTypeWrapper<OauthProviderDeletePayload>;
  OauthProviderEdge: ResolverTypeWrapper<OauthProviderEdge>;
  OauthProviderUpdatePayload: ResolverTypeWrapper<OauthProviderUpdatePayload>;
  OauthProviderWhereInput: OauthProviderWhereInput;
  OhAuthTooToken: ResolverTypeWrapper<OhAuthTooToken>;
  OhAuthTooTokenConnection: ResolverTypeWrapper<OhAuthTooTokenConnection>;
  OhAuthTooTokenCreatePayload: ResolverTypeWrapper<OhAuthTooTokenCreatePayload>;
  OhAuthTooTokenDeletePayload: ResolverTypeWrapper<OhAuthTooTokenDeletePayload>;
  OhAuthTooTokenEdge: ResolverTypeWrapper<OhAuthTooTokenEdge>;
  OhAuthTooTokenUpdatePayload: ResolverTypeWrapper<OhAuthTooTokenUpdatePayload>;
  OhAuthTooTokenWhereInput: OhAuthTooTokenWhereInput;
  OrderDirection: OrderDirection;
  OrgMembership: ResolverTypeWrapper<OrgMembership>;
  OrgMembershipConnection: ResolverTypeWrapper<OrgMembershipConnection>;
  OrgMembershipCreatePayload: ResolverTypeWrapper<OrgMembershipCreatePayload>;
  OrgMembershipDeletePayload: ResolverTypeWrapper<OrgMembershipDeletePayload>;
  OrgMembershipEdge: ResolverTypeWrapper<OrgMembershipEdge>;
  OrgMembershipRole: OrgMembershipRole;
  OrgMembershipUpdatePayload: ResolverTypeWrapper<OrgMembershipUpdatePayload>;
  OrgMembershipWhereInput: OrgMembershipWhereInput;
  Organization: ResolverTypeWrapper<Organization>;
  OrganizationConnection: ResolverTypeWrapper<OrganizationConnection>;
  OrganizationCreatePayload: ResolverTypeWrapper<OrganizationCreatePayload>;
  OrganizationDeletePayload: ResolverTypeWrapper<OrganizationDeletePayload>;
  OrganizationEdge: ResolverTypeWrapper<OrganizationEdge>;
  OrganizationOrder: OrganizationOrder;
  OrganizationOrderField: OrganizationOrderField;
  OrganizationSetting: ResolverTypeWrapper<OrganizationSetting>;
  OrganizationSettingConnection: ResolverTypeWrapper<OrganizationSettingConnection>;
  OrganizationSettingCreatePayload: ResolverTypeWrapper<OrganizationSettingCreatePayload>;
  OrganizationSettingDeletePayload: ResolverTypeWrapper<OrganizationSettingDeletePayload>;
  OrganizationSettingEdge: ResolverTypeWrapper<OrganizationSettingEdge>;
  OrganizationSettingUpdatePayload: ResolverTypeWrapper<OrganizationSettingUpdatePayload>;
  OrganizationSettingWhereInput: OrganizationSettingWhereInput;
  OrganizationUpdatePayload: ResolverTypeWrapper<OrganizationUpdatePayload>;
  OrganizationWhereInput: OrganizationWhereInput;
  PageInfo: ResolverTypeWrapper<PageInfo>;
  PersonalAccessToken: ResolverTypeWrapper<PersonalAccessToken>;
  PersonalAccessTokenConnection: ResolverTypeWrapper<PersonalAccessTokenConnection>;
  PersonalAccessTokenCreatePayload: ResolverTypeWrapper<PersonalAccessTokenCreatePayload>;
  PersonalAccessTokenDeletePayload: ResolverTypeWrapper<PersonalAccessTokenDeletePayload>;
  PersonalAccessTokenEdge: ResolverTypeWrapper<PersonalAccessTokenEdge>;
  PersonalAccessTokenUpdatePayload: ResolverTypeWrapper<PersonalAccessTokenUpdatePayload>;
  PersonalAccessTokenWhereInput: PersonalAccessTokenWhereInput;
  Query: ResolverTypeWrapper<{}>;
  Session: ResolverTypeWrapper<Session>;
  SessionConnection: ResolverTypeWrapper<SessionConnection>;
  SessionCreatePayload: ResolverTypeWrapper<SessionCreatePayload>;
  SessionDeletePayload: ResolverTypeWrapper<SessionDeletePayload>;
  SessionEdge: ResolverTypeWrapper<SessionEdge>;
  SessionUpdatePayload: ResolverTypeWrapper<SessionUpdatePayload>;
  SessionWhereInput: SessionWhereInput;
  String: ResolverTypeWrapper<Scalars['String']['output']>;
  Time: ResolverTypeWrapper<Scalars['Time']['output']>;
  UpdateEntitlementInput: UpdateEntitlementInput;
  UpdateGroupInput: UpdateGroupInput;
  UpdateGroupMembershipInput: UpdateGroupMembershipInput;
  UpdateGroupSettingInput: UpdateGroupSettingInput;
  UpdateIntegrationInput: UpdateIntegrationInput;
  UpdateOauthProviderInput: UpdateOauthProviderInput;
  UpdateOhAuthTooTokenInput: UpdateOhAuthTooTokenInput;
  UpdateOrgMembershipInput: UpdateOrgMembershipInput;
  UpdateOrganizationInput: UpdateOrganizationInput;
  UpdateOrganizationSettingInput: UpdateOrganizationSettingInput;
  UpdatePersonalAccessTokenInput: UpdatePersonalAccessTokenInput;
  UpdateSessionInput: UpdateSessionInput;
  UpdateUserInput: UpdateUserInput;
  UpdateUserSettingInput: UpdateUserSettingInput;
  User: ResolverTypeWrapper<User>;
  UserConnection: ResolverTypeWrapper<UserConnection>;
  UserCreatePayload: ResolverTypeWrapper<UserCreatePayload>;
  UserDeletePayload: ResolverTypeWrapper<UserDeletePayload>;
  UserEdge: ResolverTypeWrapper<UserEdge>;
  UserOrder: UserOrder;
  UserOrderField: UserOrderField;
  UserSetting: ResolverTypeWrapper<UserSetting>;
  UserSettingConnection: ResolverTypeWrapper<UserSettingConnection>;
  UserSettingCreatePayload: ResolverTypeWrapper<UserSettingCreatePayload>;
  UserSettingDeletePayload: ResolverTypeWrapper<UserSettingDeletePayload>;
  UserSettingEdge: ResolverTypeWrapper<UserSettingEdge>;
  UserSettingRole: UserSettingRole;
  UserSettingStatus: UserSettingStatus;
  UserSettingUpdatePayload: ResolverTypeWrapper<UserSettingUpdatePayload>;
  UserSettingWhereInput: UserSettingWhereInput;
  UserUpdatePayload: ResolverTypeWrapper<UserUpdatePayload>;
  UserWhereInput: UserWhereInput;
};

/** Mapping between all available schema types and the resolvers parents */
export type ResolversParentTypes = {
  Boolean: Scalars['Boolean']['output'];
  CreateEntitlementInput: CreateEntitlementInput;
  CreateGroupInput: CreateGroupInput;
  CreateGroupMembershipInput: CreateGroupMembershipInput;
  CreateGroupSettingInput: CreateGroupSettingInput;
  CreateIntegrationInput: CreateIntegrationInput;
  CreateOauthProviderInput: CreateOauthProviderInput;
  CreateOhAuthTooTokenInput: CreateOhAuthTooTokenInput;
  CreateOrgMembershipInput: CreateOrgMembershipInput;
  CreateOrganizationInput: CreateOrganizationInput;
  CreateOrganizationSettingInput: CreateOrganizationSettingInput;
  CreatePersonalAccessTokenInput: CreatePersonalAccessTokenInput;
  CreateSessionInput: CreateSessionInput;
  CreateUserInput: CreateUserInput;
  CreateUserSettingInput: CreateUserSettingInput;
  Cursor: Scalars['Cursor']['output'];
  Entitlement: Entitlement;
  EntitlementConnection: EntitlementConnection;
  EntitlementCreatePayload: EntitlementCreatePayload;
  EntitlementDeletePayload: EntitlementDeletePayload;
  EntitlementEdge: EntitlementEdge;
  EntitlementUpdatePayload: EntitlementUpdatePayload;
  EntitlementWhereInput: EntitlementWhereInput;
  Group: Group;
  GroupConnection: GroupConnection;
  GroupCreatePayload: GroupCreatePayload;
  GroupDeletePayload: GroupDeletePayload;
  GroupEdge: GroupEdge;
  GroupMembership: GroupMembership;
  GroupMembershipConnection: GroupMembershipConnection;
  GroupMembershipCreatePayload: GroupMembershipCreatePayload;
  GroupMembershipDeletePayload: GroupMembershipDeletePayload;
  GroupMembershipEdge: GroupMembershipEdge;
  GroupMembershipUpdatePayload: GroupMembershipUpdatePayload;
  GroupMembershipWhereInput: GroupMembershipWhereInput;
  GroupOrder: GroupOrder;
  GroupSetting: GroupSetting;
  GroupSettingConnection: GroupSettingConnection;
  GroupSettingCreatePayload: GroupSettingCreatePayload;
  GroupSettingDeletePayload: GroupSettingDeletePayload;
  GroupSettingEdge: GroupSettingEdge;
  GroupSettingUpdatePayload: GroupSettingUpdatePayload;
  GroupSettingWhereInput: GroupSettingWhereInput;
  GroupUpdatePayload: GroupUpdatePayload;
  GroupWhereInput: GroupWhereInput;
  ID: Scalars['ID']['output'];
  Int: Scalars['Int']['output'];
  Integration: Integration;
  IntegrationConnection: IntegrationConnection;
  IntegrationCreatePayload: IntegrationCreatePayload;
  IntegrationDeletePayload: IntegrationDeletePayload;
  IntegrationEdge: IntegrationEdge;
  IntegrationOrder: IntegrationOrder;
  IntegrationUpdatePayload: IntegrationUpdatePayload;
  IntegrationWhereInput: IntegrationWhereInput;
  JSON: Scalars['JSON']['output'];
  Mutation: {};
  Node: ResolversInterfaceTypes<ResolversParentTypes>['Node'];
  OauthProvider: OauthProvider;
  OauthProviderConnection: OauthProviderConnection;
  OauthProviderCreatePayload: OauthProviderCreatePayload;
  OauthProviderDeletePayload: OauthProviderDeletePayload;
  OauthProviderEdge: OauthProviderEdge;
  OauthProviderUpdatePayload: OauthProviderUpdatePayload;
  OauthProviderWhereInput: OauthProviderWhereInput;
  OhAuthTooToken: OhAuthTooToken;
  OhAuthTooTokenConnection: OhAuthTooTokenConnection;
  OhAuthTooTokenCreatePayload: OhAuthTooTokenCreatePayload;
  OhAuthTooTokenDeletePayload: OhAuthTooTokenDeletePayload;
  OhAuthTooTokenEdge: OhAuthTooTokenEdge;
  OhAuthTooTokenUpdatePayload: OhAuthTooTokenUpdatePayload;
  OhAuthTooTokenWhereInput: OhAuthTooTokenWhereInput;
  OrgMembership: OrgMembership;
  OrgMembershipConnection: OrgMembershipConnection;
  OrgMembershipCreatePayload: OrgMembershipCreatePayload;
  OrgMembershipDeletePayload: OrgMembershipDeletePayload;
  OrgMembershipEdge: OrgMembershipEdge;
  OrgMembershipUpdatePayload: OrgMembershipUpdatePayload;
  OrgMembershipWhereInput: OrgMembershipWhereInput;
  Organization: Organization;
  OrganizationConnection: OrganizationConnection;
  OrganizationCreatePayload: OrganizationCreatePayload;
  OrganizationDeletePayload: OrganizationDeletePayload;
  OrganizationEdge: OrganizationEdge;
  OrganizationOrder: OrganizationOrder;
  OrganizationSetting: OrganizationSetting;
  OrganizationSettingConnection: OrganizationSettingConnection;
  OrganizationSettingCreatePayload: OrganizationSettingCreatePayload;
  OrganizationSettingDeletePayload: OrganizationSettingDeletePayload;
  OrganizationSettingEdge: OrganizationSettingEdge;
  OrganizationSettingUpdatePayload: OrganizationSettingUpdatePayload;
  OrganizationSettingWhereInput: OrganizationSettingWhereInput;
  OrganizationUpdatePayload: OrganizationUpdatePayload;
  OrganizationWhereInput: OrganizationWhereInput;
  PageInfo: PageInfo;
  PersonalAccessToken: PersonalAccessToken;
  PersonalAccessTokenConnection: PersonalAccessTokenConnection;
  PersonalAccessTokenCreatePayload: PersonalAccessTokenCreatePayload;
  PersonalAccessTokenDeletePayload: PersonalAccessTokenDeletePayload;
  PersonalAccessTokenEdge: PersonalAccessTokenEdge;
  PersonalAccessTokenUpdatePayload: PersonalAccessTokenUpdatePayload;
  PersonalAccessTokenWhereInput: PersonalAccessTokenWhereInput;
  Query: {};
  Session: Session;
  SessionConnection: SessionConnection;
  SessionCreatePayload: SessionCreatePayload;
  SessionDeletePayload: SessionDeletePayload;
  SessionEdge: SessionEdge;
  SessionUpdatePayload: SessionUpdatePayload;
  SessionWhereInput: SessionWhereInput;
  String: Scalars['String']['output'];
  Time: Scalars['Time']['output'];
  UpdateEntitlementInput: UpdateEntitlementInput;
  UpdateGroupInput: UpdateGroupInput;
  UpdateGroupMembershipInput: UpdateGroupMembershipInput;
  UpdateGroupSettingInput: UpdateGroupSettingInput;
  UpdateIntegrationInput: UpdateIntegrationInput;
  UpdateOauthProviderInput: UpdateOauthProviderInput;
  UpdateOhAuthTooTokenInput: UpdateOhAuthTooTokenInput;
  UpdateOrgMembershipInput: UpdateOrgMembershipInput;
  UpdateOrganizationInput: UpdateOrganizationInput;
  UpdateOrganizationSettingInput: UpdateOrganizationSettingInput;
  UpdatePersonalAccessTokenInput: UpdatePersonalAccessTokenInput;
  UpdateSessionInput: UpdateSessionInput;
  UpdateUserInput: UpdateUserInput;
  UpdateUserSettingInput: UpdateUserSettingInput;
  User: User;
  UserConnection: UserConnection;
  UserCreatePayload: UserCreatePayload;
  UserDeletePayload: UserDeletePayload;
  UserEdge: UserEdge;
  UserOrder: UserOrder;
  UserSetting: UserSetting;
  UserSettingConnection: UserSettingConnection;
  UserSettingCreatePayload: UserSettingCreatePayload;
  UserSettingDeletePayload: UserSettingDeletePayload;
  UserSettingEdge: UserSettingEdge;
  UserSettingUpdatePayload: UserSettingUpdatePayload;
  UserSettingWhereInput: UserSettingWhereInput;
  UserUpdatePayload: UserUpdatePayload;
  UserWhereInput: UserWhereInput;
};

export type GoFieldDirectiveArgs = {
  forceResolver: Maybe<Scalars['Boolean']['input']>;
  name: Maybe<Scalars['String']['input']>;
};

export type GoFieldDirectiveResolver<Result, Parent, ContextType = any, Args = GoFieldDirectiveArgs> = DirectiveResolverFn<Result, Parent, ContextType, Args>;

export type GoModelDirectiveArgs = {
  model: Maybe<Scalars['String']['input']>;
  models: Maybe<Array<Scalars['String']['input']>>;
};

export type GoModelDirectiveResolver<Result, Parent, ContextType = any, Args = GoModelDirectiveArgs> = DirectiveResolverFn<Result, Parent, ContextType, Args>;

export interface CursorScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['Cursor'], any> {
  name: 'Cursor';
}

export type EntitlementResolvers<ContextType = any, ParentType extends ResolversParentTypes['Entitlement'] = ResolversParentTypes['Entitlement']> = {
  cancelled: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  createdAt: Resolver<ResolversTypes['Time'], ParentType, ContextType>;
  createdBy: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  deletedAt: Resolver<Maybe<ResolversTypes['Time']>, ParentType, ContextType>;
  deletedBy: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  expires: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  expiresAt: Resolver<Maybe<ResolversTypes['Time']>, ParentType, ContextType>;
  externalCustomerID: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  externalSubscriptionID: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  id: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  owner: Resolver<ResolversTypes['Organization'], ParentType, ContextType>;
  tier: Resolver<ResolversTypes['EntitlementTier'], ParentType, ContextType>;
  updatedAt: Resolver<ResolversTypes['Time'], ParentType, ContextType>;
  updatedBy: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type EntitlementConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['EntitlementConnection'] = ResolversParentTypes['EntitlementConnection']> = {
  edges: Resolver<Maybe<Array<Maybe<ResolversTypes['EntitlementEdge']>>>, ParentType, ContextType>;
  pageInfo: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type EntitlementCreatePayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['EntitlementCreatePayload'] = ResolversParentTypes['EntitlementCreatePayload']> = {
  entitlement: Resolver<ResolversTypes['Entitlement'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type EntitlementDeletePayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['EntitlementDeletePayload'] = ResolversParentTypes['EntitlementDeletePayload']> = {
  deletedID: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type EntitlementEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['EntitlementEdge'] = ResolversParentTypes['EntitlementEdge']> = {
  cursor: Resolver<ResolversTypes['Cursor'], ParentType, ContextType>;
  node: Resolver<Maybe<ResolversTypes['Entitlement']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type EntitlementUpdatePayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['EntitlementUpdatePayload'] = ResolversParentTypes['EntitlementUpdatePayload']> = {
  entitlement: Resolver<ResolversTypes['Entitlement'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type GroupResolvers<ContextType = any, ParentType extends ResolversParentTypes['Group'] = ResolversParentTypes['Group']> = {
  createdAt: Resolver<ResolversTypes['Time'], ParentType, ContextType>;
  createdBy: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  deletedAt: Resolver<Maybe<ResolversTypes['Time']>, ParentType, ContextType>;
  deletedBy: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  description: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  displayName: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  gravatarLogoURL: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  id: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  logoURL: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  members: Resolver<Maybe<Array<ResolversTypes['GroupMembership']>>, ParentType, ContextType>;
  name: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  owner: Resolver<ResolversTypes['Organization'], ParentType, ContextType>;
  setting: Resolver<ResolversTypes['GroupSetting'], ParentType, ContextType>;
  updatedAt: Resolver<ResolversTypes['Time'], ParentType, ContextType>;
  updatedBy: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  users: Resolver<Maybe<Array<ResolversTypes['User']>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type GroupConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['GroupConnection'] = ResolversParentTypes['GroupConnection']> = {
  edges: Resolver<Maybe<Array<Maybe<ResolversTypes['GroupEdge']>>>, ParentType, ContextType>;
  pageInfo: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type GroupCreatePayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['GroupCreatePayload'] = ResolversParentTypes['GroupCreatePayload']> = {
  group: Resolver<ResolversTypes['Group'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type GroupDeletePayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['GroupDeletePayload'] = ResolversParentTypes['GroupDeletePayload']> = {
  deletedID: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type GroupEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['GroupEdge'] = ResolversParentTypes['GroupEdge']> = {
  cursor: Resolver<ResolversTypes['Cursor'], ParentType, ContextType>;
  node: Resolver<Maybe<ResolversTypes['Group']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type GroupMembershipResolvers<ContextType = any, ParentType extends ResolversParentTypes['GroupMembership'] = ResolversParentTypes['GroupMembership']> = {
  createdAt: Resolver<ResolversTypes['Time'], ParentType, ContextType>;
  createdBy: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  deletedAt: Resolver<Maybe<ResolversTypes['Time']>, ParentType, ContextType>;
  deletedBy: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  group: Resolver<ResolversTypes['Group'], ParentType, ContextType>;
  groupID: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  id: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  role: Resolver<ResolversTypes['GroupMembershipRole'], ParentType, ContextType>;
  updatedAt: Resolver<ResolversTypes['Time'], ParentType, ContextType>;
  updatedBy: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  user: Resolver<ResolversTypes['User'], ParentType, ContextType>;
  userID: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type GroupMembershipConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['GroupMembershipConnection'] = ResolversParentTypes['GroupMembershipConnection']> = {
  edges: Resolver<Maybe<Array<Maybe<ResolversTypes['GroupMembershipEdge']>>>, ParentType, ContextType>;
  pageInfo: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type GroupMembershipCreatePayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['GroupMembershipCreatePayload'] = ResolversParentTypes['GroupMembershipCreatePayload']> = {
  groupMembership: Resolver<ResolversTypes['GroupMembership'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type GroupMembershipDeletePayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['GroupMembershipDeletePayload'] = ResolversParentTypes['GroupMembershipDeletePayload']> = {
  deletedID: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type GroupMembershipEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['GroupMembershipEdge'] = ResolversParentTypes['GroupMembershipEdge']> = {
  cursor: Resolver<ResolversTypes['Cursor'], ParentType, ContextType>;
  node: Resolver<Maybe<ResolversTypes['GroupMembership']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type GroupMembershipUpdatePayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['GroupMembershipUpdatePayload'] = ResolversParentTypes['GroupMembershipUpdatePayload']> = {
  groupMembership: Resolver<ResolversTypes['GroupMembership'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type GroupSettingResolvers<ContextType = any, ParentType extends ResolversParentTypes['GroupSetting'] = ResolversParentTypes['GroupSetting']> = {
  createdAt: Resolver<ResolversTypes['Time'], ParentType, ContextType>;
  createdBy: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  deletedAt: Resolver<Maybe<ResolversTypes['Time']>, ParentType, ContextType>;
  deletedBy: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  group: Resolver<Maybe<ResolversTypes['Group']>, ParentType, ContextType>;
  id: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  joinPolicy: Resolver<ResolversTypes['GroupSettingJoinPolicy'], ParentType, ContextType>;
  syncToGithub: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  syncToSlack: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  tags: Resolver<Array<ResolversTypes['String']>, ParentType, ContextType>;
  updatedAt: Resolver<ResolversTypes['Time'], ParentType, ContextType>;
  updatedBy: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  visibility: Resolver<ResolversTypes['GroupSettingVisibility'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type GroupSettingConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['GroupSettingConnection'] = ResolversParentTypes['GroupSettingConnection']> = {
  edges: Resolver<Maybe<Array<Maybe<ResolversTypes['GroupSettingEdge']>>>, ParentType, ContextType>;
  pageInfo: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type GroupSettingCreatePayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['GroupSettingCreatePayload'] = ResolversParentTypes['GroupSettingCreatePayload']> = {
  groupSetting: Resolver<ResolversTypes['GroupSetting'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type GroupSettingDeletePayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['GroupSettingDeletePayload'] = ResolversParentTypes['GroupSettingDeletePayload']> = {
  deletedID: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type GroupSettingEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['GroupSettingEdge'] = ResolversParentTypes['GroupSettingEdge']> = {
  cursor: Resolver<ResolversTypes['Cursor'], ParentType, ContextType>;
  node: Resolver<Maybe<ResolversTypes['GroupSetting']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type GroupSettingUpdatePayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['GroupSettingUpdatePayload'] = ResolversParentTypes['GroupSettingUpdatePayload']> = {
  groupSetting: Resolver<ResolversTypes['GroupSetting'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type GroupUpdatePayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['GroupUpdatePayload'] = ResolversParentTypes['GroupUpdatePayload']> = {
  group: Resolver<ResolversTypes['Group'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type IntegrationResolvers<ContextType = any, ParentType extends ResolversParentTypes['Integration'] = ResolversParentTypes['Integration']> = {
  createdAt: Resolver<ResolversTypes['Time'], ParentType, ContextType>;
  createdBy: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  deletedAt: Resolver<Maybe<ResolversTypes['Time']>, ParentType, ContextType>;
  deletedBy: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  description: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  id: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  kind: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  name: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  owner: Resolver<Maybe<ResolversTypes['Organization']>, ParentType, ContextType>;
  secretName: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  updatedAt: Resolver<ResolversTypes['Time'], ParentType, ContextType>;
  updatedBy: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type IntegrationConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['IntegrationConnection'] = ResolversParentTypes['IntegrationConnection']> = {
  edges: Resolver<Maybe<Array<Maybe<ResolversTypes['IntegrationEdge']>>>, ParentType, ContextType>;
  pageInfo: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type IntegrationCreatePayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['IntegrationCreatePayload'] = ResolversParentTypes['IntegrationCreatePayload']> = {
  integration: Resolver<ResolversTypes['Integration'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type IntegrationDeletePayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['IntegrationDeletePayload'] = ResolversParentTypes['IntegrationDeletePayload']> = {
  deletedID: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type IntegrationEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['IntegrationEdge'] = ResolversParentTypes['IntegrationEdge']> = {
  cursor: Resolver<ResolversTypes['Cursor'], ParentType, ContextType>;
  node: Resolver<Maybe<ResolversTypes['Integration']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type IntegrationUpdatePayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['IntegrationUpdatePayload'] = ResolversParentTypes['IntegrationUpdatePayload']> = {
  integration: Resolver<ResolversTypes['Integration'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export interface JsonScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['JSON'], any> {
  name: 'JSON';
}

export type MutationResolvers<ContextType = any, ParentType extends ResolversParentTypes['Mutation'] = ResolversParentTypes['Mutation']> = {
  createEntitlement: Resolver<ResolversTypes['EntitlementCreatePayload'], ParentType, ContextType, RequireFields<MutationCreateEntitlementArgs, 'input'>>;
  createGroup: Resolver<ResolversTypes['GroupCreatePayload'], ParentType, ContextType, RequireFields<MutationCreateGroupArgs, 'input'>>;
  createGroupMembership: Resolver<ResolversTypes['GroupMembershipCreatePayload'], ParentType, ContextType, RequireFields<MutationCreateGroupMembershipArgs, 'input'>>;
  createGroupSetting: Resolver<ResolversTypes['GroupSettingCreatePayload'], ParentType, ContextType, RequireFields<MutationCreateGroupSettingArgs, 'input'>>;
  createIntegration: Resolver<ResolversTypes['IntegrationCreatePayload'], ParentType, ContextType, RequireFields<MutationCreateIntegrationArgs, 'input'>>;
  createOauthProvider: Resolver<ResolversTypes['OauthProviderCreatePayload'], ParentType, ContextType, RequireFields<MutationCreateOauthProviderArgs, 'input'>>;
  createOhAuthTooToken: Resolver<ResolversTypes['OhAuthTooTokenCreatePayload'], ParentType, ContextType, RequireFields<MutationCreateOhAuthTooTokenArgs, 'input'>>;
  createOrgMembership: Resolver<ResolversTypes['OrgMembershipCreatePayload'], ParentType, ContextType, RequireFields<MutationCreateOrgMembershipArgs, 'input'>>;
  createOrganization: Resolver<ResolversTypes['OrganizationCreatePayload'], ParentType, ContextType, RequireFields<MutationCreateOrganizationArgs, 'input'>>;
  createOrganizationSetting: Resolver<ResolversTypes['OrganizationSettingCreatePayload'], ParentType, ContextType, RequireFields<MutationCreateOrganizationSettingArgs, 'input'>>;
  createPersonalAccessToken: Resolver<ResolversTypes['PersonalAccessTokenCreatePayload'], ParentType, ContextType, RequireFields<MutationCreatePersonalAccessTokenArgs, 'input'>>;
  createSession: Resolver<ResolversTypes['SessionCreatePayload'], ParentType, ContextType, RequireFields<MutationCreateSessionArgs, 'input'>>;
  createUser: Resolver<ResolversTypes['UserCreatePayload'], ParentType, ContextType, RequireFields<MutationCreateUserArgs, 'input'>>;
  createUserSetting: Resolver<ResolversTypes['UserSettingCreatePayload'], ParentType, ContextType, RequireFields<MutationCreateUserSettingArgs, 'input'>>;
  deleteEntitlement: Resolver<ResolversTypes['EntitlementDeletePayload'], ParentType, ContextType, RequireFields<MutationDeleteEntitlementArgs, 'id'>>;
  deleteGroup: Resolver<ResolversTypes['GroupDeletePayload'], ParentType, ContextType, RequireFields<MutationDeleteGroupArgs, 'id'>>;
  deleteGroupMembership: Resolver<ResolversTypes['GroupMembershipDeletePayload'], ParentType, ContextType, RequireFields<MutationDeleteGroupMembershipArgs, 'id'>>;
  deleteGroupSetting: Resolver<ResolversTypes['GroupSettingDeletePayload'], ParentType, ContextType, RequireFields<MutationDeleteGroupSettingArgs, 'id'>>;
  deleteIntegration: Resolver<ResolversTypes['IntegrationDeletePayload'], ParentType, ContextType, RequireFields<MutationDeleteIntegrationArgs, 'id'>>;
  deleteOauthProvider: Resolver<ResolversTypes['OauthProviderDeletePayload'], ParentType, ContextType, RequireFields<MutationDeleteOauthProviderArgs, 'id'>>;
  deleteOhAuthTooToken: Resolver<ResolversTypes['OhAuthTooTokenDeletePayload'], ParentType, ContextType, RequireFields<MutationDeleteOhAuthTooTokenArgs, 'id'>>;
  deleteOrgMembership: Resolver<ResolversTypes['OrgMembershipDeletePayload'], ParentType, ContextType, RequireFields<MutationDeleteOrgMembershipArgs, 'id'>>;
  deleteOrganization: Resolver<ResolversTypes['OrganizationDeletePayload'], ParentType, ContextType, RequireFields<MutationDeleteOrganizationArgs, 'id'>>;
  deleteOrganizationSetting: Resolver<ResolversTypes['OrganizationSettingDeletePayload'], ParentType, ContextType, RequireFields<MutationDeleteOrganizationSettingArgs, 'id'>>;
  deletePersonalAccessToken: Resolver<ResolversTypes['PersonalAccessTokenDeletePayload'], ParentType, ContextType, RequireFields<MutationDeletePersonalAccessTokenArgs, 'id'>>;
  deleteSession: Resolver<ResolversTypes['SessionDeletePayload'], ParentType, ContextType, RequireFields<MutationDeleteSessionArgs, 'id'>>;
  deleteUser: Resolver<ResolversTypes['UserDeletePayload'], ParentType, ContextType, RequireFields<MutationDeleteUserArgs, 'id'>>;
  deleteUserSetting: Resolver<ResolversTypes['UserSettingDeletePayload'], ParentType, ContextType, RequireFields<MutationDeleteUserSettingArgs, 'id'>>;
  updateEntitlement: Resolver<ResolversTypes['EntitlementUpdatePayload'], ParentType, ContextType, RequireFields<MutationUpdateEntitlementArgs, 'id' | 'input'>>;
  updateGroup: Resolver<ResolversTypes['GroupUpdatePayload'], ParentType, ContextType, RequireFields<MutationUpdateGroupArgs, 'id' | 'input'>>;
  updateGroupMembership: Resolver<ResolversTypes['GroupMembershipUpdatePayload'], ParentType, ContextType, RequireFields<MutationUpdateGroupMembershipArgs, 'id' | 'input'>>;
  updateGroupSetting: Resolver<ResolversTypes['GroupSettingUpdatePayload'], ParentType, ContextType, RequireFields<MutationUpdateGroupSettingArgs, 'id' | 'input'>>;
  updateIntegration: Resolver<ResolversTypes['IntegrationUpdatePayload'], ParentType, ContextType, RequireFields<MutationUpdateIntegrationArgs, 'id' | 'input'>>;
  updateOauthProvider: Resolver<ResolversTypes['OauthProviderUpdatePayload'], ParentType, ContextType, RequireFields<MutationUpdateOauthProviderArgs, 'id' | 'input'>>;
  updateOhAuthTooToken: Resolver<ResolversTypes['OhAuthTooTokenUpdatePayload'], ParentType, ContextType, RequireFields<MutationUpdateOhAuthTooTokenArgs, 'id' | 'input'>>;
  updateOrgMembership: Resolver<ResolversTypes['OrgMembershipUpdatePayload'], ParentType, ContextType, RequireFields<MutationUpdateOrgMembershipArgs, 'id' | 'input'>>;
  updateOrganization: Resolver<ResolversTypes['OrganizationUpdatePayload'], ParentType, ContextType, RequireFields<MutationUpdateOrganizationArgs, 'id' | 'input'>>;
  updateOrganizationSetting: Resolver<ResolversTypes['OrganizationSettingUpdatePayload'], ParentType, ContextType, RequireFields<MutationUpdateOrganizationSettingArgs, 'id' | 'input'>>;
  updatePersonalAccessToken: Resolver<ResolversTypes['PersonalAccessTokenUpdatePayload'], ParentType, ContextType, RequireFields<MutationUpdatePersonalAccessTokenArgs, 'id' | 'input'>>;
  updateSession: Resolver<ResolversTypes['SessionUpdatePayload'], ParentType, ContextType, RequireFields<MutationUpdateSessionArgs, 'id' | 'input'>>;
  updateUser: Resolver<ResolversTypes['UserUpdatePayload'], ParentType, ContextType, RequireFields<MutationUpdateUserArgs, 'id' | 'input'>>;
  updateUserSetting: Resolver<ResolversTypes['UserSettingUpdatePayload'], ParentType, ContextType, RequireFields<MutationUpdateUserSettingArgs, 'id' | 'input'>>;
};

export type NodeResolvers<ContextType = any, ParentType extends ResolversParentTypes['Node'] = ResolversParentTypes['Node']> = {
  __resolveType: TypeResolveFn<'Entitlement' | 'Group' | 'GroupMembership' | 'GroupSetting' | 'Integration' | 'OauthProvider' | 'OhAuthTooToken' | 'OrgMembership' | 'Organization' | 'OrganizationSetting' | 'PersonalAccessToken' | 'Session' | 'User' | 'UserSetting', ParentType, ContextType>;
  id: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
};

export type OauthProviderResolvers<ContextType = any, ParentType extends ResolversParentTypes['OauthProvider'] = ResolversParentTypes['OauthProvider']> = {
  authStyle: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  authURL: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  clientID: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  clientSecret: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  createdAt: Resolver<ResolversTypes['Time'], ParentType, ContextType>;
  createdBy: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  deletedAt: Resolver<Maybe<ResolversTypes['Time']>, ParentType, ContextType>;
  deletedBy: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  id: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  infoURL: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  name: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  owner: Resolver<Maybe<ResolversTypes['Organization']>, ParentType, ContextType>;
  redirectURL: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  scopes: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  tokenURL: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  updatedAt: Resolver<ResolversTypes['Time'], ParentType, ContextType>;
  updatedBy: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type OauthProviderConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['OauthProviderConnection'] = ResolversParentTypes['OauthProviderConnection']> = {
  edges: Resolver<Maybe<Array<Maybe<ResolversTypes['OauthProviderEdge']>>>, ParentType, ContextType>;
  pageInfo: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type OauthProviderCreatePayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['OauthProviderCreatePayload'] = ResolversParentTypes['OauthProviderCreatePayload']> = {
  oauthProvider: Resolver<ResolversTypes['OauthProvider'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type OauthProviderDeletePayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['OauthProviderDeletePayload'] = ResolversParentTypes['OauthProviderDeletePayload']> = {
  deletedID: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type OauthProviderEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['OauthProviderEdge'] = ResolversParentTypes['OauthProviderEdge']> = {
  cursor: Resolver<ResolversTypes['Cursor'], ParentType, ContextType>;
  node: Resolver<Maybe<ResolversTypes['OauthProvider']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type OauthProviderUpdatePayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['OauthProviderUpdatePayload'] = ResolversParentTypes['OauthProviderUpdatePayload']> = {
  oauthProvider: Resolver<ResolversTypes['OauthProvider'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type OhAuthTooTokenResolvers<ContextType = any, ParentType extends ResolversParentTypes['OhAuthTooToken'] = ResolversParentTypes['OhAuthTooToken']> = {
  claimsEmail: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  claimsEmailVerified: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  claimsGroups: Resolver<Maybe<Array<ResolversTypes['String']>>, ParentType, ContextType>;
  claimsPreferredUsername: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  claimsUserID: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  claimsUsername: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  clientID: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  connectorData: Resolver<Maybe<Array<ResolversTypes['String']>>, ParentType, ContextType>;
  connectorID: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  id: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  lastUsed: Resolver<ResolversTypes['Time'], ParentType, ContextType>;
  nonce: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  scopes: Resolver<Maybe<Array<ResolversTypes['String']>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type OhAuthTooTokenConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['OhAuthTooTokenConnection'] = ResolversParentTypes['OhAuthTooTokenConnection']> = {
  edges: Resolver<Maybe<Array<Maybe<ResolversTypes['OhAuthTooTokenEdge']>>>, ParentType, ContextType>;
  pageInfo: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type OhAuthTooTokenCreatePayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['OhAuthTooTokenCreatePayload'] = ResolversParentTypes['OhAuthTooTokenCreatePayload']> = {
  ohAuthTooToken: Resolver<ResolversTypes['OhAuthTooToken'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type OhAuthTooTokenDeletePayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['OhAuthTooTokenDeletePayload'] = ResolversParentTypes['OhAuthTooTokenDeletePayload']> = {
  deletedID: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type OhAuthTooTokenEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['OhAuthTooTokenEdge'] = ResolversParentTypes['OhAuthTooTokenEdge']> = {
  cursor: Resolver<ResolversTypes['Cursor'], ParentType, ContextType>;
  node: Resolver<Maybe<ResolversTypes['OhAuthTooToken']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type OhAuthTooTokenUpdatePayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['OhAuthTooTokenUpdatePayload'] = ResolversParentTypes['OhAuthTooTokenUpdatePayload']> = {
  ohAuthTooToken: Resolver<ResolversTypes['OhAuthTooToken'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type OrgMembershipResolvers<ContextType = any, ParentType extends ResolversParentTypes['OrgMembership'] = ResolversParentTypes['OrgMembership']> = {
  createdAt: Resolver<ResolversTypes['Time'], ParentType, ContextType>;
  createdBy: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  deletedAt: Resolver<Maybe<ResolversTypes['Time']>, ParentType, ContextType>;
  deletedBy: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  id: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  org: Resolver<ResolversTypes['Organization'], ParentType, ContextType>;
  orgID: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  role: Resolver<ResolversTypes['OrgMembershipRole'], ParentType, ContextType>;
  updatedAt: Resolver<ResolversTypes['Time'], ParentType, ContextType>;
  updatedBy: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  user: Resolver<ResolversTypes['User'], ParentType, ContextType>;
  userID: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type OrgMembershipConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['OrgMembershipConnection'] = ResolversParentTypes['OrgMembershipConnection']> = {
  edges: Resolver<Maybe<Array<Maybe<ResolversTypes['OrgMembershipEdge']>>>, ParentType, ContextType>;
  pageInfo: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type OrgMembershipCreatePayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['OrgMembershipCreatePayload'] = ResolversParentTypes['OrgMembershipCreatePayload']> = {
  orgMembership: Resolver<ResolversTypes['OrgMembership'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type OrgMembershipDeletePayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['OrgMembershipDeletePayload'] = ResolversParentTypes['OrgMembershipDeletePayload']> = {
  deletedID: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type OrgMembershipEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['OrgMembershipEdge'] = ResolversParentTypes['OrgMembershipEdge']> = {
  cursor: Resolver<ResolversTypes['Cursor'], ParentType, ContextType>;
  node: Resolver<Maybe<ResolversTypes['OrgMembership']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type OrgMembershipUpdatePayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['OrgMembershipUpdatePayload'] = ResolversParentTypes['OrgMembershipUpdatePayload']> = {
  orgMembership: Resolver<ResolversTypes['OrgMembership'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type OrganizationResolvers<ContextType = any, ParentType extends ResolversParentTypes['Organization'] = ResolversParentTypes['Organization']> = {
  children: Resolver<ResolversTypes['OrganizationConnection'], ParentType, ContextType, Partial<OrganizationChildrenArgs>>;
  createdAt: Resolver<ResolversTypes['Time'], ParentType, ContextType>;
  createdBy: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  deletedAt: Resolver<Maybe<ResolversTypes['Time']>, ParentType, ContextType>;
  deletedBy: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  description: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  displayName: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  entitlements: Resolver<Maybe<Array<ResolversTypes['Entitlement']>>, ParentType, ContextType>;
  groups: Resolver<Maybe<Array<ResolversTypes['Group']>>, ParentType, ContextType>;
  id: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  integrations: Resolver<Maybe<Array<ResolversTypes['Integration']>>, ParentType, ContextType>;
  members: Resolver<Maybe<Array<ResolversTypes['OrgMembership']>>, ParentType, ContextType>;
  name: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  oauthprovider: Resolver<Maybe<Array<ResolversTypes['OauthProvider']>>, ParentType, ContextType>;
  parent: Resolver<Maybe<ResolversTypes['Organization']>, ParentType, ContextType>;
  personalOrg: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  setting: Resolver<Maybe<ResolversTypes['OrganizationSetting']>, ParentType, ContextType>;
  updatedAt: Resolver<ResolversTypes['Time'], ParentType, ContextType>;
  updatedBy: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  users: Resolver<Maybe<Array<ResolversTypes['User']>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type OrganizationConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['OrganizationConnection'] = ResolversParentTypes['OrganizationConnection']> = {
  edges: Resolver<Maybe<Array<Maybe<ResolversTypes['OrganizationEdge']>>>, ParentType, ContextType>;
  pageInfo: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type OrganizationCreatePayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['OrganizationCreatePayload'] = ResolversParentTypes['OrganizationCreatePayload']> = {
  organization: Resolver<ResolversTypes['Organization'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type OrganizationDeletePayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['OrganizationDeletePayload'] = ResolversParentTypes['OrganizationDeletePayload']> = {
  deletedID: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type OrganizationEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['OrganizationEdge'] = ResolversParentTypes['OrganizationEdge']> = {
  cursor: Resolver<ResolversTypes['Cursor'], ParentType, ContextType>;
  node: Resolver<Maybe<ResolversTypes['Organization']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type OrganizationSettingResolvers<ContextType = any, ParentType extends ResolversParentTypes['OrganizationSetting'] = ResolversParentTypes['OrganizationSetting']> = {
  billingAddress: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  billingContact: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  billingEmail: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  billingPhone: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  createdAt: Resolver<ResolversTypes['Time'], ParentType, ContextType>;
  createdBy: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  deletedAt: Resolver<Maybe<ResolversTypes['Time']>, ParentType, ContextType>;
  deletedBy: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  domains: Resolver<Maybe<Array<ResolversTypes['String']>>, ParentType, ContextType>;
  id: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  organization: Resolver<Maybe<ResolversTypes['Organization']>, ParentType, ContextType>;
  ssoCert: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  ssoEntrypoint: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  ssoIssuer: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  tags: Resolver<Maybe<Array<ResolversTypes['String']>>, ParentType, ContextType>;
  taxIdentifier: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  updatedAt: Resolver<ResolversTypes['Time'], ParentType, ContextType>;
  updatedBy: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type OrganizationSettingConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['OrganizationSettingConnection'] = ResolversParentTypes['OrganizationSettingConnection']> = {
  edges: Resolver<Maybe<Array<Maybe<ResolversTypes['OrganizationSettingEdge']>>>, ParentType, ContextType>;
  pageInfo: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type OrganizationSettingCreatePayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['OrganizationSettingCreatePayload'] = ResolversParentTypes['OrganizationSettingCreatePayload']> = {
  organizationSetting: Resolver<ResolversTypes['OrganizationSetting'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type OrganizationSettingDeletePayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['OrganizationSettingDeletePayload'] = ResolversParentTypes['OrganizationSettingDeletePayload']> = {
  deletedID: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type OrganizationSettingEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['OrganizationSettingEdge'] = ResolversParentTypes['OrganizationSettingEdge']> = {
  cursor: Resolver<ResolversTypes['Cursor'], ParentType, ContextType>;
  node: Resolver<Maybe<ResolversTypes['OrganizationSetting']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type OrganizationSettingUpdatePayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['OrganizationSettingUpdatePayload'] = ResolversParentTypes['OrganizationSettingUpdatePayload']> = {
  organizationSetting: Resolver<ResolversTypes['OrganizationSetting'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type OrganizationUpdatePayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['OrganizationUpdatePayload'] = ResolversParentTypes['OrganizationUpdatePayload']> = {
  organization: Resolver<ResolversTypes['Organization'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type PageInfoResolvers<ContextType = any, ParentType extends ResolversParentTypes['PageInfo'] = ResolversParentTypes['PageInfo']> = {
  endCursor: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  hasNextPage: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  hasPreviousPage: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  startCursor: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type PersonalAccessTokenResolvers<ContextType = any, ParentType extends ResolversParentTypes['PersonalAccessToken'] = ResolversParentTypes['PersonalAccessToken']> = {
  abilities: Resolver<Maybe<Array<ResolversTypes['String']>>, ParentType, ContextType>;
  createdAt: Resolver<ResolversTypes['Time'], ParentType, ContextType>;
  createdBy: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  deletedAt: Resolver<Maybe<ResolversTypes['Time']>, ParentType, ContextType>;
  deletedBy: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  description: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  expiresAt: Resolver<ResolversTypes['Time'], ParentType, ContextType>;
  id: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  lastUsedAt: Resolver<Maybe<ResolversTypes['Time']>, ParentType, ContextType>;
  name: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  owner: Resolver<ResolversTypes['User'], ParentType, ContextType>;
  updatedAt: Resolver<ResolversTypes['Time'], ParentType, ContextType>;
  updatedBy: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type PersonalAccessTokenConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['PersonalAccessTokenConnection'] = ResolversParentTypes['PersonalAccessTokenConnection']> = {
  edges: Resolver<Maybe<Array<Maybe<ResolversTypes['PersonalAccessTokenEdge']>>>, ParentType, ContextType>;
  pageInfo: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type PersonalAccessTokenCreatePayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['PersonalAccessTokenCreatePayload'] = ResolversParentTypes['PersonalAccessTokenCreatePayload']> = {
  personalAccessToken: Resolver<ResolversTypes['PersonalAccessToken'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type PersonalAccessTokenDeletePayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['PersonalAccessTokenDeletePayload'] = ResolversParentTypes['PersonalAccessTokenDeletePayload']> = {
  deletedID: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type PersonalAccessTokenEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['PersonalAccessTokenEdge'] = ResolversParentTypes['PersonalAccessTokenEdge']> = {
  cursor: Resolver<ResolversTypes['Cursor'], ParentType, ContextType>;
  node: Resolver<Maybe<ResolversTypes['PersonalAccessToken']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type PersonalAccessTokenUpdatePayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['PersonalAccessTokenUpdatePayload'] = ResolversParentTypes['PersonalAccessTokenUpdatePayload']> = {
  personalAccessToken: Resolver<ResolversTypes['PersonalAccessToken'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type QueryResolvers<ContextType = any, ParentType extends ResolversParentTypes['Query'] = ResolversParentTypes['Query']> = {
  entitlement: Resolver<ResolversTypes['Entitlement'], ParentType, ContextType, RequireFields<QueryEntitlementArgs, 'id'>>;
  entitlements: Resolver<ResolversTypes['EntitlementConnection'], ParentType, ContextType, Partial<QueryEntitlementsArgs>>;
  group: Resolver<ResolversTypes['Group'], ParentType, ContextType, RequireFields<QueryGroupArgs, 'id'>>;
  groupMembership: Resolver<ResolversTypes['GroupMembership'], ParentType, ContextType, RequireFields<QueryGroupMembershipArgs, 'id'>>;
  groupMemberships: Resolver<ResolversTypes['GroupMembershipConnection'], ParentType, ContextType, Partial<QueryGroupMembershipsArgs>>;
  groupSetting: Resolver<ResolversTypes['GroupSetting'], ParentType, ContextType, RequireFields<QueryGroupSettingArgs, 'id'>>;
  groupSettings: Resolver<ResolversTypes['GroupSettingConnection'], ParentType, ContextType, Partial<QueryGroupSettingsArgs>>;
  groups: Resolver<ResolversTypes['GroupConnection'], ParentType, ContextType, Partial<QueryGroupsArgs>>;
  integration: Resolver<ResolversTypes['Integration'], ParentType, ContextType, RequireFields<QueryIntegrationArgs, 'id'>>;
  integrations: Resolver<ResolversTypes['IntegrationConnection'], ParentType, ContextType, Partial<QueryIntegrationsArgs>>;
  node: Resolver<Maybe<ResolversTypes['Node']>, ParentType, ContextType, RequireFields<QueryNodeArgs, 'id'>>;
  nodes: Resolver<Array<Maybe<ResolversTypes['Node']>>, ParentType, ContextType, RequireFields<QueryNodesArgs, 'ids'>>;
  oauthProvider: Resolver<ResolversTypes['OauthProvider'], ParentType, ContextType, RequireFields<QueryOauthProviderArgs, 'id'>>;
  oauthProviders: Resolver<ResolversTypes['OauthProviderConnection'], ParentType, ContextType, Partial<QueryOauthProvidersArgs>>;
  ohAuthTooToken: Resolver<ResolversTypes['OhAuthTooToken'], ParentType, ContextType, RequireFields<QueryOhAuthTooTokenArgs, 'id'>>;
  ohAuthTooTokens: Resolver<ResolversTypes['OhAuthTooTokenConnection'], ParentType, ContextType, Partial<QueryOhAuthTooTokensArgs>>;
  orgMembership: Resolver<ResolversTypes['OrgMembership'], ParentType, ContextType, RequireFields<QueryOrgMembershipArgs, 'id'>>;
  orgMemberships: Resolver<ResolversTypes['OrgMembershipConnection'], ParentType, ContextType, Partial<QueryOrgMembershipsArgs>>;
  organization: Resolver<ResolversTypes['Organization'], ParentType, ContextType, RequireFields<QueryOrganizationArgs, 'id'>>;
  organizationSetting: Resolver<ResolversTypes['OrganizationSetting'], ParentType, ContextType, RequireFields<QueryOrganizationSettingArgs, 'id'>>;
  organizationSettings: Resolver<ResolversTypes['OrganizationSettingConnection'], ParentType, ContextType, Partial<QueryOrganizationSettingsArgs>>;
  organizations: Resolver<ResolversTypes['OrganizationConnection'], ParentType, ContextType, Partial<QueryOrganizationsArgs>>;
  personalAccessToken: Resolver<ResolversTypes['PersonalAccessToken'], ParentType, ContextType, RequireFields<QueryPersonalAccessTokenArgs, 'id'>>;
  personalAccessTokens: Resolver<ResolversTypes['PersonalAccessTokenConnection'], ParentType, ContextType, Partial<QueryPersonalAccessTokensArgs>>;
  session: Resolver<ResolversTypes['Session'], ParentType, ContextType, RequireFields<QuerySessionArgs, 'id'>>;
  sessions: Resolver<ResolversTypes['SessionConnection'], ParentType, ContextType, Partial<QuerySessionsArgs>>;
  user: Resolver<ResolversTypes['User'], ParentType, ContextType, RequireFields<QueryUserArgs, 'id'>>;
  userSetting: Resolver<ResolversTypes['UserSetting'], ParentType, ContextType, RequireFields<QueryUserSettingArgs, 'id'>>;
  userSettings: Resolver<ResolversTypes['UserSettingConnection'], ParentType, ContextType, Partial<QueryUserSettingsArgs>>;
  users: Resolver<ResolversTypes['UserConnection'], ParentType, ContextType, Partial<QueryUsersArgs>>;
};

export type SessionResolvers<ContextType = any, ParentType extends ResolversParentTypes['Session'] = ResolversParentTypes['Session']> = {
  createdAt: Resolver<ResolversTypes['Time'], ParentType, ContextType>;
  createdBy: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  expiresAt: Resolver<ResolversTypes['Time'], ParentType, ContextType>;
  id: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  issuedAt: Resolver<ResolversTypes['Time'], ParentType, ContextType>;
  organizationID: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  owner: Resolver<ResolversTypes['User'], ParentType, ContextType>;
  sessionToken: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  updatedAt: Resolver<ResolversTypes['Time'], ParentType, ContextType>;
  updatedBy: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type SessionConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['SessionConnection'] = ResolversParentTypes['SessionConnection']> = {
  edges: Resolver<Maybe<Array<Maybe<ResolversTypes['SessionEdge']>>>, ParentType, ContextType>;
  pageInfo: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type SessionCreatePayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['SessionCreatePayload'] = ResolversParentTypes['SessionCreatePayload']> = {
  session: Resolver<ResolversTypes['Session'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type SessionDeletePayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['SessionDeletePayload'] = ResolversParentTypes['SessionDeletePayload']> = {
  deletedID: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type SessionEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['SessionEdge'] = ResolversParentTypes['SessionEdge']> = {
  cursor: Resolver<ResolversTypes['Cursor'], ParentType, ContextType>;
  node: Resolver<Maybe<ResolversTypes['Session']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type SessionUpdatePayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['SessionUpdatePayload'] = ResolversParentTypes['SessionUpdatePayload']> = {
  session: Resolver<ResolversTypes['Session'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export interface TimeScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['Time'], any> {
  name: 'Time';
}

export type UserResolvers<ContextType = any, ParentType extends ResolversParentTypes['User'] = ResolversParentTypes['User']> = {
  avatarLocalFile: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  avatarRemoteURL: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  avatarUpdatedAt: Resolver<Maybe<ResolversTypes['Time']>, ParentType, ContextType>;
  createdAt: Resolver<ResolversTypes['Time'], ParentType, ContextType>;
  createdBy: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  deletedAt: Resolver<Maybe<ResolversTypes['Time']>, ParentType, ContextType>;
  deletedBy: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  displayName: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  email: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  firstName: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  groupMemberships: Resolver<Maybe<Array<ResolversTypes['GroupMembership']>>, ParentType, ContextType>;
  groups: Resolver<Maybe<Array<ResolversTypes['Group']>>, ParentType, ContextType>;
  id: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  lastName: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  lastSeen: Resolver<Maybe<ResolversTypes['Time']>, ParentType, ContextType>;
  oauth: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  orgMemberships: Resolver<Maybe<Array<ResolversTypes['OrgMembership']>>, ParentType, ContextType>;
  organizations: Resolver<Maybe<Array<ResolversTypes['Organization']>>, ParentType, ContextType>;
  personalAccessTokens: Resolver<Maybe<Array<ResolversTypes['PersonalAccessToken']>>, ParentType, ContextType>;
  sessions: Resolver<Maybe<Array<ResolversTypes['Session']>>, ParentType, ContextType>;
  setting: Resolver<ResolversTypes['UserSetting'], ParentType, ContextType>;
  sub: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  updatedAt: Resolver<ResolversTypes['Time'], ParentType, ContextType>;
  updatedBy: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UserConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['UserConnection'] = ResolversParentTypes['UserConnection']> = {
  edges: Resolver<Maybe<Array<Maybe<ResolversTypes['UserEdge']>>>, ParentType, ContextType>;
  pageInfo: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UserCreatePayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['UserCreatePayload'] = ResolversParentTypes['UserCreatePayload']> = {
  user: Resolver<ResolversTypes['User'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UserDeletePayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['UserDeletePayload'] = ResolversParentTypes['UserDeletePayload']> = {
  deletedID: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UserEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['UserEdge'] = ResolversParentTypes['UserEdge']> = {
  cursor: Resolver<ResolversTypes['Cursor'], ParentType, ContextType>;
  node: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UserSettingResolvers<ContextType = any, ParentType extends ResolversParentTypes['UserSetting'] = ResolversParentTypes['UserSetting']> = {
  createdAt: Resolver<ResolversTypes['Time'], ParentType, ContextType>;
  createdBy: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  deletedAt: Resolver<Maybe<ResolversTypes['Time']>, ParentType, ContextType>;
  deletedBy: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  emailConfirmed: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  id: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  locked: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  permissions: Resolver<Array<ResolversTypes['String']>, ParentType, ContextType>;
  role: Resolver<ResolversTypes['UserSettingRole'], ParentType, ContextType>;
  silencedAt: Resolver<Maybe<ResolversTypes['Time']>, ParentType, ContextType>;
  status: Resolver<ResolversTypes['UserSettingStatus'], ParentType, ContextType>;
  suspendedAt: Resolver<Maybe<ResolversTypes['Time']>, ParentType, ContextType>;
  tags: Resolver<Array<ResolversTypes['String']>, ParentType, ContextType>;
  updatedAt: Resolver<ResolversTypes['Time'], ParentType, ContextType>;
  updatedBy: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  user: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UserSettingConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['UserSettingConnection'] = ResolversParentTypes['UserSettingConnection']> = {
  edges: Resolver<Maybe<Array<Maybe<ResolversTypes['UserSettingEdge']>>>, ParentType, ContextType>;
  pageInfo: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UserSettingCreatePayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['UserSettingCreatePayload'] = ResolversParentTypes['UserSettingCreatePayload']> = {
  userSetting: Resolver<ResolversTypes['UserSetting'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UserSettingDeletePayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['UserSettingDeletePayload'] = ResolversParentTypes['UserSettingDeletePayload']> = {
  deletedID: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UserSettingEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['UserSettingEdge'] = ResolversParentTypes['UserSettingEdge']> = {
  cursor: Resolver<ResolversTypes['Cursor'], ParentType, ContextType>;
  node: Resolver<Maybe<ResolversTypes['UserSetting']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UserSettingUpdatePayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['UserSettingUpdatePayload'] = ResolversParentTypes['UserSettingUpdatePayload']> = {
  userSetting: Resolver<ResolversTypes['UserSetting'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UserUpdatePayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['UserUpdatePayload'] = ResolversParentTypes['UserUpdatePayload']> = {
  user: Resolver<ResolversTypes['User'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type Resolvers<ContextType = any> = {
  Cursor: GraphQLScalarType;
  Entitlement: EntitlementResolvers<ContextType>;
  EntitlementConnection: EntitlementConnectionResolvers<ContextType>;
  EntitlementCreatePayload: EntitlementCreatePayloadResolvers<ContextType>;
  EntitlementDeletePayload: EntitlementDeletePayloadResolvers<ContextType>;
  EntitlementEdge: EntitlementEdgeResolvers<ContextType>;
  EntitlementUpdatePayload: EntitlementUpdatePayloadResolvers<ContextType>;
  Group: GroupResolvers<ContextType>;
  GroupConnection: GroupConnectionResolvers<ContextType>;
  GroupCreatePayload: GroupCreatePayloadResolvers<ContextType>;
  GroupDeletePayload: GroupDeletePayloadResolvers<ContextType>;
  GroupEdge: GroupEdgeResolvers<ContextType>;
  GroupMembership: GroupMembershipResolvers<ContextType>;
  GroupMembershipConnection: GroupMembershipConnectionResolvers<ContextType>;
  GroupMembershipCreatePayload: GroupMembershipCreatePayloadResolvers<ContextType>;
  GroupMembershipDeletePayload: GroupMembershipDeletePayloadResolvers<ContextType>;
  GroupMembershipEdge: GroupMembershipEdgeResolvers<ContextType>;
  GroupMembershipUpdatePayload: GroupMembershipUpdatePayloadResolvers<ContextType>;
  GroupSetting: GroupSettingResolvers<ContextType>;
  GroupSettingConnection: GroupSettingConnectionResolvers<ContextType>;
  GroupSettingCreatePayload: GroupSettingCreatePayloadResolvers<ContextType>;
  GroupSettingDeletePayload: GroupSettingDeletePayloadResolvers<ContextType>;
  GroupSettingEdge: GroupSettingEdgeResolvers<ContextType>;
  GroupSettingUpdatePayload: GroupSettingUpdatePayloadResolvers<ContextType>;
  GroupUpdatePayload: GroupUpdatePayloadResolvers<ContextType>;
  Integration: IntegrationResolvers<ContextType>;
  IntegrationConnection: IntegrationConnectionResolvers<ContextType>;
  IntegrationCreatePayload: IntegrationCreatePayloadResolvers<ContextType>;
  IntegrationDeletePayload: IntegrationDeletePayloadResolvers<ContextType>;
  IntegrationEdge: IntegrationEdgeResolvers<ContextType>;
  IntegrationUpdatePayload: IntegrationUpdatePayloadResolvers<ContextType>;
  JSON: GraphQLScalarType;
  Mutation: MutationResolvers<ContextType>;
  Node: NodeResolvers<ContextType>;
  OauthProvider: OauthProviderResolvers<ContextType>;
  OauthProviderConnection: OauthProviderConnectionResolvers<ContextType>;
  OauthProviderCreatePayload: OauthProviderCreatePayloadResolvers<ContextType>;
  OauthProviderDeletePayload: OauthProviderDeletePayloadResolvers<ContextType>;
  OauthProviderEdge: OauthProviderEdgeResolvers<ContextType>;
  OauthProviderUpdatePayload: OauthProviderUpdatePayloadResolvers<ContextType>;
  OhAuthTooToken: OhAuthTooTokenResolvers<ContextType>;
  OhAuthTooTokenConnection: OhAuthTooTokenConnectionResolvers<ContextType>;
  OhAuthTooTokenCreatePayload: OhAuthTooTokenCreatePayloadResolvers<ContextType>;
  OhAuthTooTokenDeletePayload: OhAuthTooTokenDeletePayloadResolvers<ContextType>;
  OhAuthTooTokenEdge: OhAuthTooTokenEdgeResolvers<ContextType>;
  OhAuthTooTokenUpdatePayload: OhAuthTooTokenUpdatePayloadResolvers<ContextType>;
  OrgMembership: OrgMembershipResolvers<ContextType>;
  OrgMembershipConnection: OrgMembershipConnectionResolvers<ContextType>;
  OrgMembershipCreatePayload: OrgMembershipCreatePayloadResolvers<ContextType>;
  OrgMembershipDeletePayload: OrgMembershipDeletePayloadResolvers<ContextType>;
  OrgMembershipEdge: OrgMembershipEdgeResolvers<ContextType>;
  OrgMembershipUpdatePayload: OrgMembershipUpdatePayloadResolvers<ContextType>;
  Organization: OrganizationResolvers<ContextType>;
  OrganizationConnection: OrganizationConnectionResolvers<ContextType>;
  OrganizationCreatePayload: OrganizationCreatePayloadResolvers<ContextType>;
  OrganizationDeletePayload: OrganizationDeletePayloadResolvers<ContextType>;
  OrganizationEdge: OrganizationEdgeResolvers<ContextType>;
  OrganizationSetting: OrganizationSettingResolvers<ContextType>;
  OrganizationSettingConnection: OrganizationSettingConnectionResolvers<ContextType>;
  OrganizationSettingCreatePayload: OrganizationSettingCreatePayloadResolvers<ContextType>;
  OrganizationSettingDeletePayload: OrganizationSettingDeletePayloadResolvers<ContextType>;
  OrganizationSettingEdge: OrganizationSettingEdgeResolvers<ContextType>;
  OrganizationSettingUpdatePayload: OrganizationSettingUpdatePayloadResolvers<ContextType>;
  OrganizationUpdatePayload: OrganizationUpdatePayloadResolvers<ContextType>;
  PageInfo: PageInfoResolvers<ContextType>;
  PersonalAccessToken: PersonalAccessTokenResolvers<ContextType>;
  PersonalAccessTokenConnection: PersonalAccessTokenConnectionResolvers<ContextType>;
  PersonalAccessTokenCreatePayload: PersonalAccessTokenCreatePayloadResolvers<ContextType>;
  PersonalAccessTokenDeletePayload: PersonalAccessTokenDeletePayloadResolvers<ContextType>;
  PersonalAccessTokenEdge: PersonalAccessTokenEdgeResolvers<ContextType>;
  PersonalAccessTokenUpdatePayload: PersonalAccessTokenUpdatePayloadResolvers<ContextType>;
  Query: QueryResolvers<ContextType>;
  Session: SessionResolvers<ContextType>;
  SessionConnection: SessionConnectionResolvers<ContextType>;
  SessionCreatePayload: SessionCreatePayloadResolvers<ContextType>;
  SessionDeletePayload: SessionDeletePayloadResolvers<ContextType>;
  SessionEdge: SessionEdgeResolvers<ContextType>;
  SessionUpdatePayload: SessionUpdatePayloadResolvers<ContextType>;
  Time: GraphQLScalarType;
  User: UserResolvers<ContextType>;
  UserConnection: UserConnectionResolvers<ContextType>;
  UserCreatePayload: UserCreatePayloadResolvers<ContextType>;
  UserDeletePayload: UserDeletePayloadResolvers<ContextType>;
  UserEdge: UserEdgeResolvers<ContextType>;
  UserSetting: UserSettingResolvers<ContextType>;
  UserSettingConnection: UserSettingConnectionResolvers<ContextType>;
  UserSettingCreatePayload: UserSettingCreatePayloadResolvers<ContextType>;
  UserSettingDeletePayload: UserSettingDeletePayloadResolvers<ContextType>;
  UserSettingEdge: UserSettingEdgeResolvers<ContextType>;
  UserSettingUpdatePayload: UserSettingUpdatePayloadResolvers<ContextType>;
  UserUpdatePayload: UserUpdatePayloadResolvers<ContextType>;
};

export type DirectiveResolvers<ContextType = any> = {
  goField: GoFieldDirectiveResolver<any, any, ContextType>;
  goModel: GoModelDirectiveResolver<any, any, ContextType>;
};


export const GetAllGroupsDocument = gql`
    query GetAllGroups {
  groups {
    edges {
      node {
        id
        name
        description
        displayName
        logoURL
        setting {
          visibility
          joinPolicy
          syncToSlack
          syncToGithub
          tags
        }
      }
    }
  }
}
    `;
export const GetUserProfileDocument = gql`
    query GetUserProfile($userId: ID!) {
  user(id: $userId) {
    id
    firstName
    lastName
    displayName
    email
    avatarRemoteURL
    setting {
      status
      tags
    }
  }
}
    `;

export type SdkFunctionWrapper = <T>(action: (requestHeaders?:Record<string, string>) => Promise<T>, operationName: string, operationType?: string, variables?: any) => Promise<T>;


const defaultWrapper: SdkFunctionWrapper = (action, _operationName, _operationType, variables) => action();

export function getSdk(client: GraphQLClient, withWrapper: SdkFunctionWrapper = defaultWrapper) {
  return {
    GetAllGroups(variables?: GetAllGroupsQueryVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<GetAllGroupsQuery> {
      return withWrapper((wrappedRequestHeaders) => client.request<GetAllGroupsQuery>(GetAllGroupsDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'GetAllGroups', 'query', variables);
    },
    GetUserProfile(variables: GetUserProfileQueryVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<GetUserProfileQuery> {
      return withWrapper((wrappedRequestHeaders) => client.request<GetUserProfileQuery>(GetUserProfileDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'GetUserProfile', 'query', variables);
    }
  };
}
export type Sdk = ReturnType<typeof getSdk>;
export function getSdkWithHooks(client: GraphQLClient, withWrapper: SdkFunctionWrapper = defaultWrapper) {
  const sdk = getSdk(client, withWrapper);
  return {
    ...sdk,
    useGetAllGroups(key: SWRKeyInterface, variables?: GetAllGroupsQueryVariables, config?: SWRConfigInterface<GetAllGroupsQuery, ClientError>) {
      return useSWR<GetAllGroupsQuery, ClientError>(key, () => sdk.GetAllGroups(variables), config);
    },
    useGetUserProfile(key: SWRKeyInterface, variables: GetUserProfileQueryVariables, config?: SWRConfigInterface<GetUserProfileQuery, ClientError>) {
      return useSWR<GetUserProfileQuery, ClientError>(key, () => sdk.GetUserProfile(variables), config);
    }
  };
}
export type SdkWithHooks = ReturnType<typeof getSdkWithHooks>;

export const GetAllGroupsDocument = gql`
    query GetAllGroups {
  groups {
    edges {
      node {
        id
        name
        description
        displayName
        logoURL
        setting {
          visibility
          joinPolicy
          syncToSlack
          syncToGithub
          tags
        }
      }
    }
  }
}
    `;

/**
 * __useGetAllGroupsQuery__
 *
 * To run a query within a React component, call `useGetAllGroupsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetAllGroupsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetAllGroupsQuery({
 *   variables: {
 *   },
 * });
 */
export function useGetAllGroupsQuery(baseOptions?: Apollo.QueryHookOptions<GetAllGroupsQuery, GetAllGroupsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetAllGroupsQuery, GetAllGroupsQueryVariables>(GetAllGroupsDocument, options);
      }
export function useGetAllGroupsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetAllGroupsQuery, GetAllGroupsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetAllGroupsQuery, GetAllGroupsQueryVariables>(GetAllGroupsDocument, options);
        }
export function useGetAllGroupsSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<GetAllGroupsQuery, GetAllGroupsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetAllGroupsQuery, GetAllGroupsQueryVariables>(GetAllGroupsDocument, options);
        }
export type GetAllGroupsQueryHookResult = ReturnType<typeof useGetAllGroupsQuery>;
export type GetAllGroupsLazyQueryHookResult = ReturnType<typeof useGetAllGroupsLazyQuery>;
export type GetAllGroupsSuspenseQueryHookResult = ReturnType<typeof useGetAllGroupsSuspenseQuery>;
export type GetAllGroupsQueryResult = Apollo.QueryResult<GetAllGroupsQuery, GetAllGroupsQueryVariables>;
export const GetUserProfileDocument = gql`
    query GetUserProfile($userId: ID!) {
  user(id: $userId) {
    id
    firstName
    lastName
    displayName
    email
    avatarRemoteURL
    setting {
      status
      tags
    }
  }
}
    `;

/**
 * __useGetUserProfileQuery__
 *
 * To run a query within a React component, call `useGetUserProfileQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetUserProfileQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetUserProfileQuery({
 *   variables: {
 *      userId: // value for 'userId'
 *   },
 * });
 */
export function useGetUserProfileQuery(baseOptions: Apollo.QueryHookOptions<GetUserProfileQuery, GetUserProfileQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetUserProfileQuery, GetUserProfileQueryVariables>(GetUserProfileDocument, options);
      }
export function useGetUserProfileLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetUserProfileQuery, GetUserProfileQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetUserProfileQuery, GetUserProfileQueryVariables>(GetUserProfileDocument, options);
        }
export function useGetUserProfileSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<GetUserProfileQuery, GetUserProfileQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetUserProfileQuery, GetUserProfileQueryVariables>(GetUserProfileDocument, options);
        }
export type GetUserProfileQueryHookResult = ReturnType<typeof useGetUserProfileQuery>;
export type GetUserProfileLazyQueryHookResult = ReturnType<typeof useGetUserProfileLazyQuery>;
export type GetUserProfileSuspenseQueryHookResult = ReturnType<typeof useGetUserProfileSuspenseQuery>;
export type GetUserProfileQueryResult = Apollo.QueryResult<GetUserProfileQuery, GetUserProfileQueryVariables>;